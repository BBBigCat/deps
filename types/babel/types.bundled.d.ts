// Generated by dts-bundle-generator v5.6.0

export interface BaseComment {
	value: string;
	start: number;
	end: number;
	loc: SourceLocation;
	type: "CommentBlock" | "CommentLine";
}
export interface CommentBlock extends BaseComment {
	type: "CommentBlock";
}
export interface CommentLine extends BaseComment {
	type: "CommentLine";
}
export declare type Comment = CommentBlock | CommentLine;
export interface SourceLocation {
	start: {
		line: number;
		column: number;
	};
	end: {
		line: number;
		column: number;
	};
}
export interface BaseNode {
	leadingComments: ReadonlyArray<Comment> | null;
	innerComments: ReadonlyArray<Comment> | null;
	trailingComments: ReadonlyArray<Comment> | null;
	start: number | null;
	end: number | null;
	loc: SourceLocation | null;
	type: Node["type"];
	extra?: Record<string, unknown>;
}
export declare type CommentTypeShorthand = "leading" | "inner" | "trailing";
export declare type Node = AnyTypeAnnotation | ArgumentPlaceholder | ArrayExpression | ArrayPattern | ArrayTypeAnnotation | ArrowFunctionExpression | AssignmentExpression | AssignmentPattern | AwaitExpression | BigIntLiteral | Binary | BinaryExpression | BindExpression | Block | BlockParent | BlockStatement | BooleanLiteral | BooleanLiteralTypeAnnotation | BooleanTypeAnnotation | BreakStatement | CallExpression | CatchClause | Class | ClassBody | ClassDeclaration | ClassExpression | ClassImplements | ClassMethod | ClassPrivateMethod | ClassPrivateProperty | ClassProperty | CompletionStatement | Conditional | ConditionalExpression | ContinueStatement | DebuggerStatement | DecimalLiteral | Declaration | DeclareClass | DeclareExportAllDeclaration | DeclareExportDeclaration | DeclareFunction | DeclareInterface | DeclareModule | DeclareModuleExports | DeclareOpaqueType | DeclareTypeAlias | DeclareVariable | DeclaredPredicate | Decorator | Directive | DirectiveLiteral | DoExpression | DoWhileStatement | EmptyStatement | EmptyTypeAnnotation | EnumBody | EnumBooleanBody | EnumBooleanMember | EnumDeclaration | EnumDefaultedMember | EnumMember | EnumNumberBody | EnumNumberMember | EnumStringBody | EnumStringMember | EnumSymbolBody | ExistsTypeAnnotation | ExportAllDeclaration | ExportDeclaration | ExportDefaultDeclaration | ExportDefaultSpecifier | ExportNamedDeclaration | ExportNamespaceSpecifier | ExportSpecifier | Expression | ExpressionStatement | ExpressionWrapper | File | Flow | FlowBaseAnnotation | FlowDeclaration | FlowPredicate | FlowType | For | ForInStatement | ForOfStatement | ForStatement | ForXStatement | Function | FunctionDeclaration | FunctionExpression | FunctionParent | FunctionTypeAnnotation | FunctionTypeParam | GenericTypeAnnotation | Identifier | IfStatement | Immutable | Import | ImportAttribute | ImportDeclaration | ImportDefaultSpecifier | ImportNamespaceSpecifier | ImportSpecifier | InferredPredicate | InterfaceDeclaration | InterfaceExtends | InterfaceTypeAnnotation | InterpreterDirective | IntersectionTypeAnnotation | JSX | JSXAttribute | JSXClosingElement | JSXClosingFragment | JSXElement | JSXEmptyExpression | JSXExpressionContainer | JSXFragment | JSXIdentifier | JSXMemberExpression | JSXNamespacedName | JSXOpeningElement | JSXOpeningFragment | JSXSpreadAttribute | JSXSpreadChild | JSXText | LVal | LabeledStatement | Literal | LogicalExpression | Loop | MemberExpression | MetaProperty | Method | MixedTypeAnnotation | ModuleDeclaration | ModuleSpecifier | NewExpression | Noop | NullLiteral | NullLiteralTypeAnnotation | NullableTypeAnnotation | NumberLiteral | NumberLiteralTypeAnnotation | NumberTypeAnnotation | NumericLiteral | ObjectExpression | ObjectMember | ObjectMethod | ObjectPattern | ObjectProperty | ObjectTypeAnnotation | ObjectTypeCallProperty | ObjectTypeIndexer | ObjectTypeInternalSlot | ObjectTypeProperty | ObjectTypeSpreadProperty | OpaqueType | OptionalCallExpression | OptionalMemberExpression | ParenthesizedExpression | Pattern | PatternLike | PipelineBareFunction | PipelinePrimaryTopicReference | PipelineTopicExpression | Placeholder | Private | PrivateName | Program | Property | Pureish | QualifiedTypeIdentifier | RecordExpression | RegExpLiteral | RegexLiteral | RestElement | RestProperty | ReturnStatement | Scopable | SequenceExpression | SpreadElement | SpreadProperty | Statement | StaticBlock | StringLiteral | StringLiteralTypeAnnotation | StringTypeAnnotation | Super | SwitchCase | SwitchStatement | SymbolTypeAnnotation | TSAnyKeyword | TSArrayType | TSAsExpression | TSBaseType | TSBigIntKeyword | TSBooleanKeyword | TSCallSignatureDeclaration | TSConditionalType | TSConstructSignatureDeclaration | TSConstructorType | TSDeclareFunction | TSDeclareMethod | TSEntityName | TSEnumDeclaration | TSEnumMember | TSExportAssignment | TSExpressionWithTypeArguments | TSExternalModuleReference | TSFunctionType | TSImportEqualsDeclaration | TSImportType | TSIndexSignature | TSIndexedAccessType | TSInferType | TSInterfaceBody | TSInterfaceDeclaration | TSIntersectionType | TSIntrinsicKeyword | TSLiteralType | TSMappedType | TSMethodSignature | TSModuleBlock | TSModuleDeclaration | TSNamedTupleMember | TSNamespaceExportDeclaration | TSNeverKeyword | TSNonNullExpression | TSNullKeyword | TSNumberKeyword | TSObjectKeyword | TSOptionalType | TSParameterProperty | TSParenthesizedType | TSPropertySignature | TSQualifiedName | TSRestType | TSStringKeyword | TSSymbolKeyword | TSThisType | TSTupleType | TSType | TSTypeAliasDeclaration | TSTypeAnnotation | TSTypeAssertion | TSTypeElement | TSTypeLiteral | TSTypeOperator | TSTypeParameter | TSTypeParameterDeclaration | TSTypeParameterInstantiation | TSTypePredicate | TSTypeQuery | TSTypeReference | TSUndefinedKeyword | TSUnionType | TSUnknownKeyword | TSVoidKeyword | TaggedTemplateExpression | TemplateElement | TemplateLiteral | Terminatorless | ThisExpression | ThisTypeAnnotation | ThrowStatement | TryStatement | TupleExpression | TupleTypeAnnotation | TypeAlias | TypeAnnotation | TypeCastExpression | TypeParameter | TypeParameterDeclaration | TypeParameterInstantiation | TypeofTypeAnnotation | UnaryExpression | UnaryLike | UnionTypeAnnotation | UpdateExpression | UserWhitespacable | V8IntrinsicIdentifier | VariableDeclaration | VariableDeclarator | Variance | VoidTypeAnnotation | While | WhileStatement | WithStatement | YieldExpression;
export interface ArrayExpression extends BaseNode {
	type: "ArrayExpression";
	elements: Array<null | Expression | SpreadElement>;
}
export interface AssignmentExpression extends BaseNode {
	type: "AssignmentExpression";
	operator: string;
	left: LVal;
	right: Expression;
}
export interface BinaryExpression extends BaseNode {
	type: "BinaryExpression";
	operator: "+" | "-" | "/" | "%" | "*" | "**" | "&" | "|" | ">>" | ">>>" | "<<" | "^" | "==" | "===" | "!=" | "!==" | "in" | "instanceof" | ">" | "<" | ">=" | "<=";
	left: Expression | PrivateName;
	right: Expression;
}
export interface InterpreterDirective extends BaseNode {
	type: "InterpreterDirective";
	value: string;
}
export interface Directive extends BaseNode {
	type: "Directive";
	value: DirectiveLiteral;
}
export interface DirectiveLiteral extends BaseNode {
	type: "DirectiveLiteral";
	value: string;
}
export interface BlockStatement extends BaseNode {
	type: "BlockStatement";
	body: Array<Statement>;
	directives: Array<Directive>;
}
export interface BreakStatement extends BaseNode {
	type: "BreakStatement";
	label?: Identifier | null;
}
export interface CallExpression extends BaseNode {
	type: "CallExpression";
	callee: Expression | V8IntrinsicIdentifier;
	arguments: Array<Expression | SpreadElement | JSXNamespacedName | ArgumentPlaceholder>;
	optional?: true | false | null;
	typeArguments?: TypeParameterInstantiation | null;
	typeParameters?: TSTypeParameterInstantiation | null;
}
export interface CatchClause extends BaseNode {
	type: "CatchClause";
	param?: Identifier | ArrayPattern | ObjectPattern | null;
	body: BlockStatement;
}
export interface ConditionalExpression extends BaseNode {
	type: "ConditionalExpression";
	test: Expression;
	consequent: Expression;
	alternate: Expression;
}
export interface ContinueStatement extends BaseNode {
	type: "ContinueStatement";
	label?: Identifier | null;
}
export interface DebuggerStatement extends BaseNode {
	type: "DebuggerStatement";
}
export interface DoWhileStatement extends BaseNode {
	type: "DoWhileStatement";
	test: Expression;
	body: Statement;
}
export interface EmptyStatement extends BaseNode {
	type: "EmptyStatement";
}
export interface ExpressionStatement extends BaseNode {
	type: "ExpressionStatement";
	expression: Expression;
}
export interface File extends BaseNode {
	type: "File";
	program: Program;
	comments?: Array<CommentBlock | CommentLine> | null;
	tokens?: Array<any> | null;
}
export interface ForInStatement extends BaseNode {
	type: "ForInStatement";
	left: VariableDeclaration | LVal;
	right: Expression;
	body: Statement;
}
export interface ForStatement extends BaseNode {
	type: "ForStatement";
	init?: VariableDeclaration | Expression | null;
	test?: Expression | null;
	update?: Expression | null;
	body: Statement;
}
export interface FunctionDeclaration extends BaseNode {
	type: "FunctionDeclaration";
	id?: Identifier | null;
	params: Array<Identifier | Pattern | RestElement | TSParameterProperty>;
	body: BlockStatement;
	generator?: boolean;
	async?: boolean;
	declare?: boolean | null;
	returnType?: TypeAnnotation | TSTypeAnnotation | Noop | null;
	typeParameters?: TypeParameterDeclaration | TSTypeParameterDeclaration | Noop | null;
}
export interface FunctionExpression extends BaseNode {
	type: "FunctionExpression";
	id?: Identifier | null;
	params: Array<Identifier | Pattern | RestElement | TSParameterProperty>;
	body: BlockStatement;
	generator?: boolean;
	async?: boolean;
	returnType?: TypeAnnotation | TSTypeAnnotation | Noop | null;
	typeParameters?: TypeParameterDeclaration | TSTypeParameterDeclaration | Noop | null;
}
export interface Identifier extends BaseNode {
	type: "Identifier";
	name: string;
	decorators?: Array<Decorator> | null;
	optional?: boolean | null;
	typeAnnotation?: TypeAnnotation | TSTypeAnnotation | Noop | null;
}
export interface IfStatement extends BaseNode {
	type: "IfStatement";
	test: Expression;
	consequent: Statement;
	alternate?: Statement | null;
}
export interface LabeledStatement extends BaseNode {
	type: "LabeledStatement";
	label: Identifier;
	body: Statement;
}
export interface StringLiteral extends BaseNode {
	type: "StringLiteral";
	value: string;
}
export interface NumericLiteral extends BaseNode {
	type: "NumericLiteral";
	value: number;
}
/**
 * @deprecated Use `NumericLiteral`
 */
export interface NumberLiteral extends BaseNode {
	type: "NumberLiteral";
	value: number;
}
export interface NullLiteral extends BaseNode {
	type: "NullLiteral";
}
export interface BooleanLiteral extends BaseNode {
	type: "BooleanLiteral";
	value: boolean;
}
export interface RegExpLiteral extends BaseNode {
	type: "RegExpLiteral";
	pattern: string;
	flags: string;
}
/**
 * @deprecated Use `RegExpLiteral`
 */
export interface RegexLiteral extends BaseNode {
	type: "RegexLiteral";
	pattern: string;
	flags: string;
}
export interface LogicalExpression extends BaseNode {
	type: "LogicalExpression";
	operator: "||" | "&&" | "??";
	left: Expression;
	right: Expression;
}
export interface MemberExpression extends BaseNode {
	type: "MemberExpression";
	object: Expression;
	property: Expression | Identifier | PrivateName;
	computed: boolean;
	optional?: true | false | null;
}
export interface NewExpression extends BaseNode {
	type: "NewExpression";
	callee: Expression | V8IntrinsicIdentifier;
	arguments: Array<Expression | SpreadElement | JSXNamespacedName | ArgumentPlaceholder>;
	optional?: true | false | null;
	typeArguments?: TypeParameterInstantiation | null;
	typeParameters?: TSTypeParameterInstantiation | null;
}
export interface Program extends BaseNode {
	type: "Program";
	body: Array<Statement>;
	directives: Array<Directive>;
	sourceType: "script" | "module";
	interpreter?: InterpreterDirective | null;
	sourceFile: string;
}
export interface ObjectExpression extends BaseNode {
	type: "ObjectExpression";
	properties: Array<ObjectMethod | ObjectProperty | SpreadElement>;
}
export interface ObjectMethod extends BaseNode {
	type: "ObjectMethod";
	kind: "method" | "get" | "set";
	key: Expression | Identifier | StringLiteral | NumericLiteral;
	params: Array<Identifier | Pattern | RestElement | TSParameterProperty>;
	body: BlockStatement;
	computed: boolean;
	generator?: boolean;
	async?: boolean;
	decorators?: Array<Decorator> | null;
	returnType?: TypeAnnotation | TSTypeAnnotation | Noop | null;
	typeParameters?: TypeParameterDeclaration | TSTypeParameterDeclaration | Noop | null;
}
export interface ObjectProperty extends BaseNode {
	type: "ObjectProperty";
	key: Expression | Identifier | StringLiteral | NumericLiteral;
	value: Expression | PatternLike;
	computed: boolean;
	shorthand: boolean;
	decorators?: Array<Decorator> | null;
}
export interface RestElement extends BaseNode {
	type: "RestElement";
	argument: LVal;
	decorators?: Array<Decorator> | null;
	typeAnnotation?: TypeAnnotation | TSTypeAnnotation | Noop | null;
}
/**
 * @deprecated Use `RestElement`
 */
export interface RestProperty extends BaseNode {
	type: "RestProperty";
	argument: LVal;
	decorators?: Array<Decorator> | null;
	typeAnnotation?: TypeAnnotation | TSTypeAnnotation | Noop | null;
}
export interface ReturnStatement extends BaseNode {
	type: "ReturnStatement";
	argument?: Expression | null;
}
export interface SequenceExpression extends BaseNode {
	type: "SequenceExpression";
	expressions: Array<Expression>;
}
export interface ParenthesizedExpression extends BaseNode {
	type: "ParenthesizedExpression";
	expression: Expression;
}
export interface SwitchCase extends BaseNode {
	type: "SwitchCase";
	test?: Expression | null;
	consequent: Array<Statement>;
}
export interface SwitchStatement extends BaseNode {
	type: "SwitchStatement";
	discriminant: Expression;
	cases: Array<SwitchCase>;
}
export interface ThisExpression extends BaseNode {
	type: "ThisExpression";
}
export interface ThrowStatement extends BaseNode {
	type: "ThrowStatement";
	argument: Expression;
}
export interface TryStatement extends BaseNode {
	type: "TryStatement";
	block: BlockStatement;
	handler?: CatchClause | null;
	finalizer?: BlockStatement | null;
}
export interface UnaryExpression extends BaseNode {
	type: "UnaryExpression";
	operator: "void" | "throw" | "delete" | "!" | "+" | "-" | "~" | "typeof";
	argument: Expression;
	prefix: boolean;
}
export interface UpdateExpression extends BaseNode {
	type: "UpdateExpression";
	operator: "++" | "--";
	argument: Expression;
	prefix: boolean;
}
export interface VariableDeclaration extends BaseNode {
	type: "VariableDeclaration";
	kind: "var" | "let" | "const";
	declarations: Array<VariableDeclarator>;
	declare?: boolean | null;
}
export interface VariableDeclarator extends BaseNode {
	type: "VariableDeclarator";
	id: LVal;
	init?: Expression | null;
	definite?: boolean | null;
}
export interface WhileStatement extends BaseNode {
	type: "WhileStatement";
	test: Expression;
	body: Statement;
}
export interface WithStatement extends BaseNode {
	type: "WithStatement";
	object: Expression;
	body: Statement;
}
export interface AssignmentPattern extends BaseNode {
	type: "AssignmentPattern";
	left: Identifier | ObjectPattern | ArrayPattern | MemberExpression;
	right: Expression;
	decorators?: Array<Decorator> | null;
	typeAnnotation?: TypeAnnotation | TSTypeAnnotation | Noop | null;
}
export interface ArrayPattern extends BaseNode {
	type: "ArrayPattern";
	elements: Array<null | PatternLike>;
	decorators?: Array<Decorator> | null;
	typeAnnotation?: TypeAnnotation | TSTypeAnnotation | Noop | null;
}
export interface ArrowFunctionExpression extends BaseNode {
	type: "ArrowFunctionExpression";
	params: Array<Identifier | Pattern | RestElement | TSParameterProperty>;
	body: BlockStatement | Expression;
	async?: boolean;
	expression: boolean;
	generator?: boolean;
	returnType?: TypeAnnotation | TSTypeAnnotation | Noop | null;
	typeParameters?: TypeParameterDeclaration | TSTypeParameterDeclaration | Noop | null;
}
export interface ClassBody extends BaseNode {
	type: "ClassBody";
	body: Array<ClassMethod | ClassPrivateMethod | ClassProperty | ClassPrivateProperty | TSDeclareMethod | TSIndexSignature>;
}
export interface ClassExpression extends BaseNode {
	type: "ClassExpression";
	id?: Identifier | null;
	superClass?: Expression | null;
	body: ClassBody;
	decorators?: Array<Decorator> | null;
	implements?: Array<TSExpressionWithTypeArguments | ClassImplements> | null;
	mixins?: InterfaceExtends | null;
	superTypeParameters?: TypeParameterInstantiation | TSTypeParameterInstantiation | null;
	typeParameters?: TypeParameterDeclaration | TSTypeParameterDeclaration | Noop | null;
}
export interface ClassDeclaration extends BaseNode {
	type: "ClassDeclaration";
	id: Identifier;
	superClass?: Expression | null;
	body: ClassBody;
	decorators?: Array<Decorator> | null;
	abstract?: boolean | null;
	declare?: boolean | null;
	implements?: Array<TSExpressionWithTypeArguments | ClassImplements> | null;
	mixins?: InterfaceExtends | null;
	superTypeParameters?: TypeParameterInstantiation | TSTypeParameterInstantiation | null;
	typeParameters?: TypeParameterDeclaration | TSTypeParameterDeclaration | Noop | null;
}
export interface ExportAllDeclaration extends BaseNode {
	type: "ExportAllDeclaration";
	source: StringLiteral;
	assertions?: ImportAttribute | null;
	exportKind?: "type" | "value" | null;
}
export interface ExportDefaultDeclaration extends BaseNode {
	type: "ExportDefaultDeclaration";
	declaration: FunctionDeclaration | TSDeclareFunction | ClassDeclaration | Expression;
}
export interface ExportNamedDeclaration extends BaseNode {
	type: "ExportNamedDeclaration";
	declaration?: Declaration | null;
	specifiers: Array<ExportSpecifier | ExportDefaultSpecifier | ExportNamespaceSpecifier>;
	source?: StringLiteral | null;
	assertions?: ImportAttribute | null;
	exportKind?: "type" | "value" | null;
}
export interface ExportSpecifier extends BaseNode {
	type: "ExportSpecifier";
	local: Identifier;
	exported: Identifier | StringLiteral;
}
export interface ForOfStatement extends BaseNode {
	type: "ForOfStatement";
	left: VariableDeclaration | LVal;
	right: Expression;
	body: Statement;
	await: boolean;
}
export interface ImportDeclaration extends BaseNode {
	type: "ImportDeclaration";
	specifiers: Array<ImportSpecifier | ImportDefaultSpecifier | ImportNamespaceSpecifier>;
	source: StringLiteral;
	assertions?: ImportAttribute | null;
	importKind?: "type" | "typeof" | "value" | null;
}
export interface ImportDefaultSpecifier extends BaseNode {
	type: "ImportDefaultSpecifier";
	local: Identifier;
}
export interface ImportNamespaceSpecifier extends BaseNode {
	type: "ImportNamespaceSpecifier";
	local: Identifier;
}
export interface ImportSpecifier extends BaseNode {
	type: "ImportSpecifier";
	local: Identifier;
	imported: Identifier | StringLiteral;
	importKind?: "type" | "typeof" | null;
}
export interface MetaProperty extends BaseNode {
	type: "MetaProperty";
	meta: Identifier;
	property: Identifier;
}
export interface ClassMethod extends BaseNode {
	type: "ClassMethod";
	kind?: "get" | "set" | "method" | "constructor";
	key: Identifier | StringLiteral | NumericLiteral | Expression;
	params: Array<Identifier | Pattern | RestElement | TSParameterProperty>;
	body: BlockStatement;
	computed?: boolean;
	static?: boolean;
	generator?: boolean;
	async?: boolean;
	abstract?: boolean | null;
	access?: "public" | "private" | "protected" | null;
	accessibility?: "public" | "private" | "protected" | null;
	decorators?: Array<Decorator> | null;
	optional?: boolean | null;
	returnType?: TypeAnnotation | TSTypeAnnotation | Noop | null;
	typeParameters?: TypeParameterDeclaration | TSTypeParameterDeclaration | Noop | null;
}
export interface ObjectPattern extends BaseNode {
	type: "ObjectPattern";
	properties: Array<RestElement | ObjectProperty>;
	decorators?: Array<Decorator> | null;
	typeAnnotation?: TypeAnnotation | TSTypeAnnotation | Noop | null;
}
export interface SpreadElement extends BaseNode {
	type: "SpreadElement";
	argument: Expression;
}
/**
 * @deprecated Use `SpreadElement`
 */
export interface SpreadProperty extends BaseNode {
	type: "SpreadProperty";
	argument: Expression;
}
export interface Super extends BaseNode {
	type: "Super";
}
export interface TaggedTemplateExpression extends BaseNode {
	type: "TaggedTemplateExpression";
	tag: Expression;
	quasi: TemplateLiteral;
	typeParameters?: TypeParameterInstantiation | TSTypeParameterInstantiation | null;
}
export interface TemplateElement extends BaseNode {
	type: "TemplateElement";
	value: {
		raw: string;
		cooked?: string;
	};
	tail: boolean;
}
export interface TemplateLiteral extends BaseNode {
	type: "TemplateLiteral";
	quasis: Array<TemplateElement>;
	expressions: Array<Expression | TSType>;
}
export interface YieldExpression extends BaseNode {
	type: "YieldExpression";
	argument?: Expression | null;
	delegate: boolean;
}
export interface AwaitExpression extends BaseNode {
	type: "AwaitExpression";
	argument: Expression;
}
export interface Import extends BaseNode {
	type: "Import";
}
export interface BigIntLiteral extends BaseNode {
	type: "BigIntLiteral";
	value: string;
}
export interface ExportNamespaceSpecifier extends BaseNode {
	type: "ExportNamespaceSpecifier";
	exported: Identifier;
}
export interface OptionalMemberExpression extends BaseNode {
	type: "OptionalMemberExpression";
	object: Expression;
	property: Expression | Identifier;
	computed: boolean;
	optional: boolean;
}
export interface OptionalCallExpression extends BaseNode {
	type: "OptionalCallExpression";
	callee: Expression;
	arguments: Array<Expression | SpreadElement | JSXNamespacedName | ArgumentPlaceholder>;
	optional: boolean;
	typeArguments?: TypeParameterInstantiation | null;
	typeParameters?: TSTypeParameterInstantiation | null;
}
export interface AnyTypeAnnotation extends BaseNode {
	type: "AnyTypeAnnotation";
}
export interface ArrayTypeAnnotation extends BaseNode {
	type: "ArrayTypeAnnotation";
	elementType: FlowType;
}
export interface BooleanTypeAnnotation extends BaseNode {
	type: "BooleanTypeAnnotation";
}
export interface BooleanLiteralTypeAnnotation extends BaseNode {
	type: "BooleanLiteralTypeAnnotation";
	value: boolean;
}
export interface NullLiteralTypeAnnotation extends BaseNode {
	type: "NullLiteralTypeAnnotation";
}
export interface ClassImplements extends BaseNode {
	type: "ClassImplements";
	id: Identifier;
	typeParameters?: TypeParameterInstantiation | null;
}
export interface DeclareClass extends BaseNode {
	type: "DeclareClass";
	id: Identifier;
	typeParameters?: TypeParameterDeclaration | null;
	extends?: Array<InterfaceExtends> | null;
	body: ObjectTypeAnnotation;
	implements?: Array<ClassImplements> | null;
	mixins?: Array<InterfaceExtends> | null;
}
export interface DeclareFunction extends BaseNode {
	type: "DeclareFunction";
	id: Identifier;
	predicate?: DeclaredPredicate | null;
}
export interface DeclareInterface extends BaseNode {
	type: "DeclareInterface";
	id: Identifier;
	typeParameters?: TypeParameterDeclaration | null;
	extends?: Array<InterfaceExtends> | null;
	body: ObjectTypeAnnotation;
	implements?: Array<ClassImplements> | null;
	mixins?: Array<InterfaceExtends> | null;
}
export interface DeclareModule extends BaseNode {
	type: "DeclareModule";
	id: Identifier | StringLiteral;
	body: BlockStatement;
	kind?: "CommonJS" | "ES" | null;
}
export interface DeclareModuleExports extends BaseNode {
	type: "DeclareModuleExports";
	typeAnnotation: TypeAnnotation;
}
export interface DeclareTypeAlias extends BaseNode {
	type: "DeclareTypeAlias";
	id: Identifier;
	typeParameters?: TypeParameterDeclaration | null;
	right: FlowType;
}
export interface DeclareOpaqueType extends BaseNode {
	type: "DeclareOpaqueType";
	id: Identifier;
	typeParameters?: TypeParameterDeclaration | null;
	supertype?: FlowType | null;
}
export interface DeclareVariable extends BaseNode {
	type: "DeclareVariable";
	id: Identifier;
}
export interface DeclareExportDeclaration extends BaseNode {
	type: "DeclareExportDeclaration";
	declaration?: Flow | null;
	specifiers?: Array<ExportSpecifier | ExportNamespaceSpecifier> | null;
	source?: StringLiteral | null;
	default?: boolean | null;
}
export interface DeclareExportAllDeclaration extends BaseNode {
	type: "DeclareExportAllDeclaration";
	source: StringLiteral;
	exportKind?: "type" | "value" | null;
}
export interface DeclaredPredicate extends BaseNode {
	type: "DeclaredPredicate";
	value: Flow;
}
export interface ExistsTypeAnnotation extends BaseNode {
	type: "ExistsTypeAnnotation";
}
export interface FunctionTypeAnnotation extends BaseNode {
	type: "FunctionTypeAnnotation";
	typeParameters?: TypeParameterDeclaration | null;
	params: Array<FunctionTypeParam>;
	rest?: FunctionTypeParam | null;
	returnType: FlowType;
}
export interface FunctionTypeParam extends BaseNode {
	type: "FunctionTypeParam";
	name?: Identifier | null;
	typeAnnotation: FlowType;
	optional?: boolean | null;
}
export interface GenericTypeAnnotation extends BaseNode {
	type: "GenericTypeAnnotation";
	id: Identifier | QualifiedTypeIdentifier;
	typeParameters?: TypeParameterInstantiation | null;
}
export interface InferredPredicate extends BaseNode {
	type: "InferredPredicate";
}
export interface InterfaceExtends extends BaseNode {
	type: "InterfaceExtends";
	id: Identifier | QualifiedTypeIdentifier;
	typeParameters?: TypeParameterInstantiation | null;
}
export interface InterfaceDeclaration extends BaseNode {
	type: "InterfaceDeclaration";
	id: Identifier;
	typeParameters?: TypeParameterDeclaration | null;
	extends?: Array<InterfaceExtends> | null;
	body: ObjectTypeAnnotation;
	implements?: Array<ClassImplements> | null;
	mixins?: Array<InterfaceExtends> | null;
}
export interface InterfaceTypeAnnotation extends BaseNode {
	type: "InterfaceTypeAnnotation";
	extends?: Array<InterfaceExtends> | null;
	body: ObjectTypeAnnotation;
}
export interface IntersectionTypeAnnotation extends BaseNode {
	type: "IntersectionTypeAnnotation";
	types: Array<FlowType>;
}
export interface MixedTypeAnnotation extends BaseNode {
	type: "MixedTypeAnnotation";
}
export interface EmptyTypeAnnotation extends BaseNode {
	type: "EmptyTypeAnnotation";
}
export interface NullableTypeAnnotation extends BaseNode {
	type: "NullableTypeAnnotation";
	typeAnnotation: FlowType;
}
export interface NumberLiteralTypeAnnotation extends BaseNode {
	type: "NumberLiteralTypeAnnotation";
	value: number;
}
export interface NumberTypeAnnotation extends BaseNode {
	type: "NumberTypeAnnotation";
}
export interface ObjectTypeAnnotation extends BaseNode {
	type: "ObjectTypeAnnotation";
	properties: Array<ObjectTypeProperty | ObjectTypeSpreadProperty>;
	indexers?: Array<ObjectTypeIndexer> | null;
	callProperties?: Array<ObjectTypeCallProperty> | null;
	internalSlots?: Array<ObjectTypeInternalSlot> | null;
	exact: boolean;
	inexact?: boolean | null;
}
export interface ObjectTypeInternalSlot extends BaseNode {
	type: "ObjectTypeInternalSlot";
	id: Identifier;
	value: FlowType;
	optional: boolean;
	static: boolean;
	method: boolean;
}
export interface ObjectTypeCallProperty extends BaseNode {
	type: "ObjectTypeCallProperty";
	value: FlowType;
	static: boolean;
}
export interface ObjectTypeIndexer extends BaseNode {
	type: "ObjectTypeIndexer";
	id?: Identifier | null;
	key: FlowType;
	value: FlowType;
	variance?: Variance | null;
	static: boolean;
}
export interface ObjectTypeProperty extends BaseNode {
	type: "ObjectTypeProperty";
	key: Identifier | StringLiteral;
	value: FlowType;
	variance?: Variance | null;
	kind: "init" | "get" | "set";
	method: boolean;
	optional: boolean;
	proto: boolean;
	static: boolean;
}
export interface ObjectTypeSpreadProperty extends BaseNode {
	type: "ObjectTypeSpreadProperty";
	argument: FlowType;
}
export interface OpaqueType extends BaseNode {
	type: "OpaqueType";
	id: Identifier;
	typeParameters?: TypeParameterDeclaration | null;
	supertype?: FlowType | null;
	impltype: FlowType;
}
export interface QualifiedTypeIdentifier extends BaseNode {
	type: "QualifiedTypeIdentifier";
	id: Identifier;
	qualification: Identifier | QualifiedTypeIdentifier;
}
export interface StringLiteralTypeAnnotation extends BaseNode {
	type: "StringLiteralTypeAnnotation";
	value: string;
}
export interface StringTypeAnnotation extends BaseNode {
	type: "StringTypeAnnotation";
}
export interface SymbolTypeAnnotation extends BaseNode {
	type: "SymbolTypeAnnotation";
}
export interface ThisTypeAnnotation extends BaseNode {
	type: "ThisTypeAnnotation";
}
export interface TupleTypeAnnotation extends BaseNode {
	type: "TupleTypeAnnotation";
	types: Array<FlowType>;
}
export interface TypeofTypeAnnotation extends BaseNode {
	type: "TypeofTypeAnnotation";
	argument: FlowType;
}
export interface TypeAlias extends BaseNode {
	type: "TypeAlias";
	id: Identifier;
	typeParameters?: TypeParameterDeclaration | null;
	right: FlowType;
}
export interface TypeAnnotation extends BaseNode {
	type: "TypeAnnotation";
	typeAnnotation: FlowType;
}
export interface TypeCastExpression extends BaseNode {
	type: "TypeCastExpression";
	expression: Expression;
	typeAnnotation: TypeAnnotation;
}
export interface TypeParameter extends BaseNode {
	type: "TypeParameter";
	bound?: TypeAnnotation | null;
	default?: FlowType | null;
	variance?: Variance | null;
	name: string;
}
export interface TypeParameterDeclaration extends BaseNode {
	type: "TypeParameterDeclaration";
	params: Array<TypeParameter>;
}
export interface TypeParameterInstantiation extends BaseNode {
	type: "TypeParameterInstantiation";
	params: Array<FlowType>;
}
export interface UnionTypeAnnotation extends BaseNode {
	type: "UnionTypeAnnotation";
	types: Array<FlowType>;
}
export interface Variance extends BaseNode {
	type: "Variance";
	kind: "minus" | "plus";
}
export interface VoidTypeAnnotation extends BaseNode {
	type: "VoidTypeAnnotation";
}
export interface EnumDeclaration extends BaseNode {
	type: "EnumDeclaration";
	id: Identifier;
	body: EnumBooleanBody | EnumNumberBody | EnumStringBody | EnumSymbolBody;
}
export interface EnumBooleanBody extends BaseNode {
	type: "EnumBooleanBody";
	members: Array<EnumBooleanMember>;
	explicitType: boolean;
}
export interface EnumNumberBody extends BaseNode {
	type: "EnumNumberBody";
	members: Array<EnumNumberMember>;
	explicitType: boolean;
}
export interface EnumStringBody extends BaseNode {
	type: "EnumStringBody";
	members: Array<EnumStringMember | EnumDefaultedMember>;
	explicitType: boolean;
}
export interface EnumSymbolBody extends BaseNode {
	type: "EnumSymbolBody";
	members: Array<EnumDefaultedMember>;
}
export interface EnumBooleanMember extends BaseNode {
	type: "EnumBooleanMember";
	id: Identifier;
	init: BooleanLiteral;
}
export interface EnumNumberMember extends BaseNode {
	type: "EnumNumberMember";
	id: Identifier;
	init: NumericLiteral;
}
export interface EnumStringMember extends BaseNode {
	type: "EnumStringMember";
	id: Identifier;
	init: StringLiteral;
}
export interface EnumDefaultedMember extends BaseNode {
	type: "EnumDefaultedMember";
	id: Identifier;
}
export interface JSXAttribute extends BaseNode {
	type: "JSXAttribute";
	name: JSXIdentifier | JSXNamespacedName;
	value?: JSXElement | JSXFragment | StringLiteral | JSXExpressionContainer | null;
}
export interface JSXClosingElement extends BaseNode {
	type: "JSXClosingElement";
	name: JSXIdentifier | JSXMemberExpression | JSXNamespacedName;
}
export interface JSXElement extends BaseNode {
	type: "JSXElement";
	openingElement: JSXOpeningElement;
	closingElement?: JSXClosingElement | null;
	children: Array<JSXText | JSXExpressionContainer | JSXSpreadChild | JSXElement | JSXFragment>;
	selfClosing?: boolean | null;
}
export interface JSXEmptyExpression extends BaseNode {
	type: "JSXEmptyExpression";
}
export interface JSXExpressionContainer extends BaseNode {
	type: "JSXExpressionContainer";
	expression: Expression | JSXEmptyExpression;
}
export interface JSXSpreadChild extends BaseNode {
	type: "JSXSpreadChild";
	expression: Expression;
}
export interface JSXIdentifier extends BaseNode {
	type: "JSXIdentifier";
	name: string;
}
export interface JSXMemberExpression extends BaseNode {
	type: "JSXMemberExpression";
	object: JSXMemberExpression | JSXIdentifier;
	property: JSXIdentifier;
}
export interface JSXNamespacedName extends BaseNode {
	type: "JSXNamespacedName";
	namespace: JSXIdentifier;
	name: JSXIdentifier;
}
export interface JSXOpeningElement extends BaseNode {
	type: "JSXOpeningElement";
	name: JSXIdentifier | JSXMemberExpression | JSXNamespacedName;
	attributes: Array<JSXAttribute | JSXSpreadAttribute>;
	selfClosing: boolean;
	typeParameters?: TypeParameterInstantiation | TSTypeParameterInstantiation | null;
}
export interface JSXSpreadAttribute extends BaseNode {
	type: "JSXSpreadAttribute";
	argument: Expression;
}
export interface JSXText extends BaseNode {
	type: "JSXText";
	value: string;
}
export interface JSXFragment extends BaseNode {
	type: "JSXFragment";
	openingFragment: JSXOpeningFragment;
	closingFragment: JSXClosingFragment;
	children: Array<JSXText | JSXExpressionContainer | JSXSpreadChild | JSXElement | JSXFragment>;
}
export interface JSXOpeningFragment extends BaseNode {
	type: "JSXOpeningFragment";
}
export interface JSXClosingFragment extends BaseNode {
	type: "JSXClosingFragment";
}
export interface Noop extends BaseNode {
	type: "Noop";
}
export interface Placeholder extends BaseNode {
	type: "Placeholder";
	expectedNode: "Identifier" | "StringLiteral" | "Expression" | "Statement" | "Declaration" | "BlockStatement" | "ClassBody" | "Pattern";
	name: Identifier;
}
export interface V8IntrinsicIdentifier extends BaseNode {
	type: "V8IntrinsicIdentifier";
	name: string;
}
export interface ArgumentPlaceholder extends BaseNode {
	type: "ArgumentPlaceholder";
}
export interface BindExpression extends BaseNode {
	type: "BindExpression";
	object: Expression;
	callee: Expression;
}
export interface ClassProperty extends BaseNode {
	type: "ClassProperty";
	key: Identifier | StringLiteral | NumericLiteral | Expression;
	value?: Expression | null;
	typeAnnotation?: TypeAnnotation | TSTypeAnnotation | Noop | null;
	decorators?: Array<Decorator> | null;
	computed?: boolean;
	static?: boolean;
	abstract?: boolean | null;
	accessibility?: "public" | "private" | "protected" | null;
	declare?: boolean | null;
	definite?: boolean | null;
	optional?: boolean | null;
	readonly?: boolean | null;
}
export interface PipelineTopicExpression extends BaseNode {
	type: "PipelineTopicExpression";
	expression: Expression;
}
export interface PipelineBareFunction extends BaseNode {
	type: "PipelineBareFunction";
	callee: Expression;
}
export interface PipelinePrimaryTopicReference extends BaseNode {
	type: "PipelinePrimaryTopicReference";
}
export interface ClassPrivateProperty extends BaseNode {
	type: "ClassPrivateProperty";
	key: PrivateName;
	value?: Expression | null;
	decorators?: Array<Decorator> | null;
	static: any;
	typeAnnotation?: TypeAnnotation | TSTypeAnnotation | Noop | null;
}
export interface ClassPrivateMethod extends BaseNode {
	type: "ClassPrivateMethod";
	kind?: "get" | "set" | "method" | "constructor";
	key: PrivateName;
	params: Array<Identifier | Pattern | RestElement | TSParameterProperty>;
	body: BlockStatement;
	static?: boolean;
	abstract?: boolean | null;
	access?: "public" | "private" | "protected" | null;
	accessibility?: "public" | "private" | "protected" | null;
	async?: boolean;
	computed?: boolean;
	decorators?: Array<Decorator> | null;
	generator?: boolean;
	optional?: boolean | null;
	returnType?: TypeAnnotation | TSTypeAnnotation | Noop | null;
	typeParameters?: TypeParameterDeclaration | TSTypeParameterDeclaration | Noop | null;
}
export interface ImportAttribute extends BaseNode {
	type: "ImportAttribute";
	key: Identifier | StringLiteral;
	value: StringLiteral;
}
export interface Decorator extends BaseNode {
	type: "Decorator";
	expression: Expression;
}
export interface DoExpression extends BaseNode {
	type: "DoExpression";
	body: BlockStatement;
}
export interface ExportDefaultSpecifier extends BaseNode {
	type: "ExportDefaultSpecifier";
	exported: Identifier;
}
export interface PrivateName extends BaseNode {
	type: "PrivateName";
	id: Identifier;
}
export interface RecordExpression extends BaseNode {
	type: "RecordExpression";
	properties: Array<ObjectProperty | SpreadElement>;
}
export interface TupleExpression extends BaseNode {
	type: "TupleExpression";
	elements: Array<Expression | SpreadElement>;
}
export interface DecimalLiteral extends BaseNode {
	type: "DecimalLiteral";
	value: string;
}
export interface StaticBlock extends BaseNode {
	type: "StaticBlock";
	body: Array<Statement>;
}
export interface TSParameterProperty extends BaseNode {
	type: "TSParameterProperty";
	parameter: Identifier | AssignmentPattern;
	accessibility?: "public" | "private" | "protected" | null;
	readonly?: boolean | null;
}
export interface TSDeclareFunction extends BaseNode {
	type: "TSDeclareFunction";
	id?: Identifier | null;
	typeParameters?: TSTypeParameterDeclaration | Noop | null;
	params: Array<Identifier | Pattern | RestElement | TSParameterProperty>;
	returnType?: TSTypeAnnotation | Noop | null;
	async?: boolean;
	declare?: boolean | null;
	generator?: boolean;
}
export interface TSDeclareMethod extends BaseNode {
	type: "TSDeclareMethod";
	decorators?: Array<Decorator> | null;
	key: Identifier | StringLiteral | NumericLiteral | Expression;
	typeParameters?: TSTypeParameterDeclaration | Noop | null;
	params: Array<Identifier | Pattern | RestElement | TSParameterProperty>;
	returnType?: TSTypeAnnotation | Noop | null;
	abstract?: boolean | null;
	access?: "public" | "private" | "protected" | null;
	accessibility?: "public" | "private" | "protected" | null;
	async?: boolean;
	computed?: boolean;
	generator?: boolean;
	kind?: "get" | "set" | "method" | "constructor";
	optional?: boolean | null;
	static?: boolean;
}
export interface TSQualifiedName extends BaseNode {
	type: "TSQualifiedName";
	left: TSEntityName;
	right: Identifier;
}
export interface TSCallSignatureDeclaration extends BaseNode {
	type: "TSCallSignatureDeclaration";
	typeParameters?: TSTypeParameterDeclaration | null;
	parameters: Array<Identifier | RestElement>;
	typeAnnotation?: TSTypeAnnotation | null;
}
export interface TSConstructSignatureDeclaration extends BaseNode {
	type: "TSConstructSignatureDeclaration";
	typeParameters?: TSTypeParameterDeclaration | null;
	parameters: Array<Identifier | RestElement>;
	typeAnnotation?: TSTypeAnnotation | null;
}
export interface TSPropertySignature extends BaseNode {
	type: "TSPropertySignature";
	key: Expression;
	typeAnnotation?: TSTypeAnnotation | null;
	initializer?: Expression | null;
	computed?: boolean | null;
	optional?: boolean | null;
	readonly?: boolean | null;
}
export interface TSMethodSignature extends BaseNode {
	type: "TSMethodSignature";
	key: Expression;
	typeParameters?: TSTypeParameterDeclaration | null;
	parameters: Array<Identifier | RestElement>;
	typeAnnotation?: TSTypeAnnotation | null;
	computed?: boolean | null;
	optional?: boolean | null;
}
export interface TSIndexSignature extends BaseNode {
	type: "TSIndexSignature";
	parameters: Array<Identifier>;
	typeAnnotation?: TSTypeAnnotation | null;
	readonly?: boolean | null;
}
export interface TSAnyKeyword extends BaseNode {
	type: "TSAnyKeyword";
}
export interface TSBooleanKeyword extends BaseNode {
	type: "TSBooleanKeyword";
}
export interface TSBigIntKeyword extends BaseNode {
	type: "TSBigIntKeyword";
}
export interface TSIntrinsicKeyword extends BaseNode {
	type: "TSIntrinsicKeyword";
}
export interface TSNeverKeyword extends BaseNode {
	type: "TSNeverKeyword";
}
export interface TSNullKeyword extends BaseNode {
	type: "TSNullKeyword";
}
export interface TSNumberKeyword extends BaseNode {
	type: "TSNumberKeyword";
}
export interface TSObjectKeyword extends BaseNode {
	type: "TSObjectKeyword";
}
export interface TSStringKeyword extends BaseNode {
	type: "TSStringKeyword";
}
export interface TSSymbolKeyword extends BaseNode {
	type: "TSSymbolKeyword";
}
export interface TSUndefinedKeyword extends BaseNode {
	type: "TSUndefinedKeyword";
}
export interface TSUnknownKeyword extends BaseNode {
	type: "TSUnknownKeyword";
}
export interface TSVoidKeyword extends BaseNode {
	type: "TSVoidKeyword";
}
export interface TSThisType extends BaseNode {
	type: "TSThisType";
}
export interface TSFunctionType extends BaseNode {
	type: "TSFunctionType";
	typeParameters?: TSTypeParameterDeclaration | null;
	parameters: Array<Identifier | RestElement>;
	typeAnnotation?: TSTypeAnnotation | null;
}
export interface TSConstructorType extends BaseNode {
	type: "TSConstructorType";
	typeParameters?: TSTypeParameterDeclaration | null;
	parameters: Array<Identifier | RestElement>;
	typeAnnotation?: TSTypeAnnotation | null;
}
export interface TSTypeReference extends BaseNode {
	type: "TSTypeReference";
	typeName: TSEntityName;
	typeParameters?: TSTypeParameterInstantiation | null;
}
export interface TSTypePredicate extends BaseNode {
	type: "TSTypePredicate";
	parameterName: Identifier | TSThisType;
	typeAnnotation?: TSTypeAnnotation | null;
	asserts?: boolean | null;
}
export interface TSTypeQuery extends BaseNode {
	type: "TSTypeQuery";
	exprName: TSEntityName | TSImportType;
}
export interface TSTypeLiteral extends BaseNode {
	type: "TSTypeLiteral";
	members: Array<TSTypeElement>;
}
export interface TSArrayType extends BaseNode {
	type: "TSArrayType";
	elementType: TSType;
}
export interface TSTupleType extends BaseNode {
	type: "TSTupleType";
	elementTypes: Array<TSType | TSNamedTupleMember>;
}
export interface TSOptionalType extends BaseNode {
	type: "TSOptionalType";
	typeAnnotation: TSType;
}
export interface TSRestType extends BaseNode {
	type: "TSRestType";
	typeAnnotation: TSType;
}
export interface TSNamedTupleMember extends BaseNode {
	type: "TSNamedTupleMember";
	label: Identifier;
	elementType: TSType;
	optional: boolean;
}
export interface TSUnionType extends BaseNode {
	type: "TSUnionType";
	types: Array<TSType>;
}
export interface TSIntersectionType extends BaseNode {
	type: "TSIntersectionType";
	types: Array<TSType>;
}
export interface TSConditionalType extends BaseNode {
	type: "TSConditionalType";
	checkType: TSType;
	extendsType: TSType;
	trueType: TSType;
	falseType: TSType;
}
export interface TSInferType extends BaseNode {
	type: "TSInferType";
	typeParameter: TSTypeParameter;
}
export interface TSParenthesizedType extends BaseNode {
	type: "TSParenthesizedType";
	typeAnnotation: TSType;
}
export interface TSTypeOperator extends BaseNode {
	type: "TSTypeOperator";
	typeAnnotation: TSType;
	operator: string;
}
export interface TSIndexedAccessType extends BaseNode {
	type: "TSIndexedAccessType";
	objectType: TSType;
	indexType: TSType;
}
export interface TSMappedType extends BaseNode {
	type: "TSMappedType";
	typeParameter: TSTypeParameter;
	typeAnnotation?: TSType | null;
	nameType?: TSType | null;
	optional?: boolean | null;
	readonly?: boolean | null;
}
export interface TSLiteralType extends BaseNode {
	type: "TSLiteralType";
	literal: NumericLiteral | StringLiteral | BooleanLiteral | BigIntLiteral;
}
export interface TSExpressionWithTypeArguments extends BaseNode {
	type: "TSExpressionWithTypeArguments";
	expression: TSEntityName;
	typeParameters?: TSTypeParameterInstantiation | null;
}
export interface TSInterfaceDeclaration extends BaseNode {
	type: "TSInterfaceDeclaration";
	id: Identifier;
	typeParameters?: TSTypeParameterDeclaration | null;
	extends?: Array<TSExpressionWithTypeArguments> | null;
	body: TSInterfaceBody;
	declare?: boolean | null;
}
export interface TSInterfaceBody extends BaseNode {
	type: "TSInterfaceBody";
	body: Array<TSTypeElement>;
}
export interface TSTypeAliasDeclaration extends BaseNode {
	type: "TSTypeAliasDeclaration";
	id: Identifier;
	typeParameters?: TSTypeParameterDeclaration | null;
	typeAnnotation: TSType;
	declare?: boolean | null;
}
export interface TSAsExpression extends BaseNode {
	type: "TSAsExpression";
	expression: Expression;
	typeAnnotation: TSType;
}
export interface TSTypeAssertion extends BaseNode {
	type: "TSTypeAssertion";
	typeAnnotation: TSType;
	expression: Expression;
}
export interface TSEnumDeclaration extends BaseNode {
	type: "TSEnumDeclaration";
	id: Identifier;
	members: Array<TSEnumMember>;
	const?: boolean | null;
	declare?: boolean | null;
	initializer?: Expression | null;
}
export interface TSEnumMember extends BaseNode {
	type: "TSEnumMember";
	id: Identifier | StringLiteral;
	initializer?: Expression | null;
}
export interface TSModuleDeclaration extends BaseNode {
	type: "TSModuleDeclaration";
	id: Identifier | StringLiteral;
	body: TSModuleBlock | TSModuleDeclaration;
	declare?: boolean | null;
	global?: boolean | null;
}
export interface TSModuleBlock extends BaseNode {
	type: "TSModuleBlock";
	body: Array<Statement>;
}
export interface TSImportType extends BaseNode {
	type: "TSImportType";
	argument: StringLiteral;
	qualifier?: TSEntityName | null;
	typeParameters?: TSTypeParameterInstantiation | null;
}
export interface TSImportEqualsDeclaration extends BaseNode {
	type: "TSImportEqualsDeclaration";
	id: Identifier;
	moduleReference: TSEntityName | TSExternalModuleReference;
	isExport: boolean;
}
export interface TSExternalModuleReference extends BaseNode {
	type: "TSExternalModuleReference";
	expression: StringLiteral;
}
export interface TSNonNullExpression extends BaseNode {
	type: "TSNonNullExpression";
	expression: Expression;
}
export interface TSExportAssignment extends BaseNode {
	type: "TSExportAssignment";
	expression: Expression;
}
export interface TSNamespaceExportDeclaration extends BaseNode {
	type: "TSNamespaceExportDeclaration";
	id: Identifier;
}
export interface TSTypeAnnotation extends BaseNode {
	type: "TSTypeAnnotation";
	typeAnnotation: TSType;
}
export interface TSTypeParameterInstantiation extends BaseNode {
	type: "TSTypeParameterInstantiation";
	params: Array<TSType>;
}
export interface TSTypeParameterDeclaration extends BaseNode {
	type: "TSTypeParameterDeclaration";
	params: Array<TSTypeParameter>;
}
export interface TSTypeParameter extends BaseNode {
	type: "TSTypeParameter";
	constraint?: TSType | null;
	default?: TSType | null;
	name: string;
}
export declare type Expression = ArrayExpression | AssignmentExpression | BinaryExpression | CallExpression | ConditionalExpression | FunctionExpression | Identifier | StringLiteral | NumericLiteral | NullLiteral | BooleanLiteral | RegExpLiteral | LogicalExpression | MemberExpression | NewExpression | ObjectExpression | SequenceExpression | ParenthesizedExpression | ThisExpression | UnaryExpression | UpdateExpression | ArrowFunctionExpression | ClassExpression | MetaProperty | Super | TaggedTemplateExpression | TemplateLiteral | YieldExpression | AwaitExpression | Import | BigIntLiteral | OptionalMemberExpression | OptionalCallExpression | TypeCastExpression | JSXElement | JSXFragment | BindExpression | PipelinePrimaryTopicReference | DoExpression | RecordExpression | TupleExpression | DecimalLiteral | TSAsExpression | TSTypeAssertion | TSNonNullExpression;
export declare type Binary = BinaryExpression | LogicalExpression;
export declare type Scopable = BlockStatement | CatchClause | DoWhileStatement | ForInStatement | ForStatement | FunctionDeclaration | FunctionExpression | Program | ObjectMethod | SwitchStatement | WhileStatement | ArrowFunctionExpression | ClassExpression | ClassDeclaration | ForOfStatement | ClassMethod | ClassPrivateMethod | StaticBlock | TSModuleBlock;
export declare type BlockParent = BlockStatement | CatchClause | DoWhileStatement | ForInStatement | ForStatement | FunctionDeclaration | FunctionExpression | Program | ObjectMethod | SwitchStatement | WhileStatement | ArrowFunctionExpression | ForOfStatement | ClassMethod | ClassPrivateMethod | StaticBlock | TSModuleBlock;
export declare type Block = BlockStatement | Program | TSModuleBlock;
export declare type Statement = BlockStatement | BreakStatement | ContinueStatement | DebuggerStatement | DoWhileStatement | EmptyStatement | ExpressionStatement | ForInStatement | ForStatement | FunctionDeclaration | IfStatement | LabeledStatement | ReturnStatement | SwitchStatement | ThrowStatement | TryStatement | VariableDeclaration | WhileStatement | WithStatement | ClassDeclaration | ExportAllDeclaration | ExportDefaultDeclaration | ExportNamedDeclaration | ForOfStatement | ImportDeclaration | DeclareClass | DeclareFunction | DeclareInterface | DeclareModule | DeclareModuleExports | DeclareTypeAlias | DeclareOpaqueType | DeclareVariable | DeclareExportDeclaration | DeclareExportAllDeclaration | InterfaceDeclaration | OpaqueType | TypeAlias | EnumDeclaration | TSDeclareFunction | TSInterfaceDeclaration | TSTypeAliasDeclaration | TSEnumDeclaration | TSModuleDeclaration | TSImportEqualsDeclaration | TSExportAssignment | TSNamespaceExportDeclaration;
export declare type Terminatorless = BreakStatement | ContinueStatement | ReturnStatement | ThrowStatement | YieldExpression | AwaitExpression;
export declare type CompletionStatement = BreakStatement | ContinueStatement | ReturnStatement | ThrowStatement;
export declare type Conditional = ConditionalExpression | IfStatement;
export declare type Loop = DoWhileStatement | ForInStatement | ForStatement | WhileStatement | ForOfStatement;
export declare type While = DoWhileStatement | WhileStatement;
export declare type ExpressionWrapper = ExpressionStatement | ParenthesizedExpression | TypeCastExpression;
export declare type For = ForInStatement | ForStatement | ForOfStatement;
export declare type ForXStatement = ForInStatement | ForOfStatement;
export declare type Function = FunctionDeclaration | FunctionExpression | ObjectMethod | ArrowFunctionExpression | ClassMethod | ClassPrivateMethod;
export declare type FunctionParent = FunctionDeclaration | FunctionExpression | ObjectMethod | ArrowFunctionExpression | ClassMethod | ClassPrivateMethod;
export declare type Pureish = FunctionDeclaration | FunctionExpression | StringLiteral | NumericLiteral | NullLiteral | BooleanLiteral | RegExpLiteral | ArrowFunctionExpression | BigIntLiteral | DecimalLiteral;
export declare type Declaration = FunctionDeclaration | VariableDeclaration | ClassDeclaration | ExportAllDeclaration | ExportDefaultDeclaration | ExportNamedDeclaration | ImportDeclaration | DeclareClass | DeclareFunction | DeclareInterface | DeclareModule | DeclareModuleExports | DeclareTypeAlias | DeclareOpaqueType | DeclareVariable | DeclareExportDeclaration | DeclareExportAllDeclaration | InterfaceDeclaration | OpaqueType | TypeAlias | EnumDeclaration | TSDeclareFunction | TSInterfaceDeclaration | TSTypeAliasDeclaration | TSEnumDeclaration | TSModuleDeclaration;
export declare type PatternLike = Identifier | RestElement | AssignmentPattern | ArrayPattern | ObjectPattern;
export declare type LVal = Identifier | MemberExpression | RestElement | AssignmentPattern | ArrayPattern | ObjectPattern | TSParameterProperty;
export declare type TSEntityName = Identifier | TSQualifiedName;
export declare type Literal = StringLiteral | NumericLiteral | NullLiteral | BooleanLiteral | RegExpLiteral | TemplateLiteral | BigIntLiteral | DecimalLiteral;
export declare type Immutable = StringLiteral | NumericLiteral | NullLiteral | BooleanLiteral | BigIntLiteral | JSXAttribute | JSXClosingElement | JSXElement | JSXExpressionContainer | JSXSpreadChild | JSXOpeningElement | JSXText | JSXFragment | JSXOpeningFragment | JSXClosingFragment | DecimalLiteral;
export declare type UserWhitespacable = ObjectMethod | ObjectProperty | ObjectTypeInternalSlot | ObjectTypeCallProperty | ObjectTypeIndexer | ObjectTypeProperty | ObjectTypeSpreadProperty;
export declare type Method = ObjectMethod | ClassMethod | ClassPrivateMethod;
export declare type ObjectMember = ObjectMethod | ObjectProperty;
export declare type Property = ObjectProperty | ClassProperty | ClassPrivateProperty;
export declare type UnaryLike = UnaryExpression | SpreadElement;
export declare type Pattern = AssignmentPattern | ArrayPattern | ObjectPattern;
export declare type Class = ClassExpression | ClassDeclaration;
export declare type ModuleDeclaration = ExportAllDeclaration | ExportDefaultDeclaration | ExportNamedDeclaration | ImportDeclaration;
export declare type ExportDeclaration = ExportAllDeclaration | ExportDefaultDeclaration | ExportNamedDeclaration;
export declare type ModuleSpecifier = ExportSpecifier | ImportDefaultSpecifier | ImportNamespaceSpecifier | ImportSpecifier | ExportNamespaceSpecifier | ExportDefaultSpecifier;
export declare type Flow = AnyTypeAnnotation | ArrayTypeAnnotation | BooleanTypeAnnotation | BooleanLiteralTypeAnnotation | NullLiteralTypeAnnotation | ClassImplements | DeclareClass | DeclareFunction | DeclareInterface | DeclareModule | DeclareModuleExports | DeclareTypeAlias | DeclareOpaqueType | DeclareVariable | DeclareExportDeclaration | DeclareExportAllDeclaration | DeclaredPredicate | ExistsTypeAnnotation | FunctionTypeAnnotation | FunctionTypeParam | GenericTypeAnnotation | InferredPredicate | InterfaceExtends | InterfaceDeclaration | InterfaceTypeAnnotation | IntersectionTypeAnnotation | MixedTypeAnnotation | EmptyTypeAnnotation | NullableTypeAnnotation | NumberLiteralTypeAnnotation | NumberTypeAnnotation | ObjectTypeAnnotation | ObjectTypeInternalSlot | ObjectTypeCallProperty | ObjectTypeIndexer | ObjectTypeProperty | ObjectTypeSpreadProperty | OpaqueType | QualifiedTypeIdentifier | StringLiteralTypeAnnotation | StringTypeAnnotation | SymbolTypeAnnotation | ThisTypeAnnotation | TupleTypeAnnotation | TypeofTypeAnnotation | TypeAlias | TypeAnnotation | TypeCastExpression | TypeParameter | TypeParameterDeclaration | TypeParameterInstantiation | UnionTypeAnnotation | Variance | VoidTypeAnnotation;
export declare type FlowType = AnyTypeAnnotation | ArrayTypeAnnotation | BooleanTypeAnnotation | BooleanLiteralTypeAnnotation | NullLiteralTypeAnnotation | ExistsTypeAnnotation | FunctionTypeAnnotation | GenericTypeAnnotation | InterfaceTypeAnnotation | IntersectionTypeAnnotation | MixedTypeAnnotation | EmptyTypeAnnotation | NullableTypeAnnotation | NumberLiteralTypeAnnotation | NumberTypeAnnotation | ObjectTypeAnnotation | StringLiteralTypeAnnotation | StringTypeAnnotation | SymbolTypeAnnotation | ThisTypeAnnotation | TupleTypeAnnotation | TypeofTypeAnnotation | UnionTypeAnnotation | VoidTypeAnnotation;
export declare type FlowBaseAnnotation = AnyTypeAnnotation | BooleanTypeAnnotation | NullLiteralTypeAnnotation | MixedTypeAnnotation | EmptyTypeAnnotation | NumberTypeAnnotation | StringTypeAnnotation | SymbolTypeAnnotation | ThisTypeAnnotation | VoidTypeAnnotation;
export declare type FlowDeclaration = DeclareClass | DeclareFunction | DeclareInterface | DeclareModule | DeclareModuleExports | DeclareTypeAlias | DeclareOpaqueType | DeclareVariable | DeclareExportDeclaration | DeclareExportAllDeclaration | InterfaceDeclaration | OpaqueType | TypeAlias;
export declare type FlowPredicate = DeclaredPredicate | InferredPredicate;
export declare type EnumBody = EnumBooleanBody | EnumNumberBody | EnumStringBody | EnumSymbolBody;
export declare type EnumMember = EnumBooleanMember | EnumNumberMember | EnumStringMember | EnumDefaultedMember;
export declare type JSX = JSXAttribute | JSXClosingElement | JSXElement | JSXEmptyExpression | JSXExpressionContainer | JSXSpreadChild | JSXIdentifier | JSXMemberExpression | JSXNamespacedName | JSXOpeningElement | JSXSpreadAttribute | JSXText | JSXFragment | JSXOpeningFragment | JSXClosingFragment;
export declare type Private = ClassPrivateProperty | ClassPrivateMethod | PrivateName;
export declare type TSTypeElement = TSCallSignatureDeclaration | TSConstructSignatureDeclaration | TSPropertySignature | TSMethodSignature | TSIndexSignature;
export declare type TSType = TSAnyKeyword | TSBooleanKeyword | TSBigIntKeyword | TSIntrinsicKeyword | TSNeverKeyword | TSNullKeyword | TSNumberKeyword | TSObjectKeyword | TSStringKeyword | TSSymbolKeyword | TSUndefinedKeyword | TSUnknownKeyword | TSVoidKeyword | TSThisType | TSFunctionType | TSConstructorType | TSTypeReference | TSTypePredicate | TSTypeQuery | TSTypeLiteral | TSArrayType | TSTupleType | TSOptionalType | TSRestType | TSUnionType | TSIntersectionType | TSConditionalType | TSInferType | TSParenthesizedType | TSTypeOperator | TSIndexedAccessType | TSMappedType | TSLiteralType | TSExpressionWithTypeArguments | TSImportType;
export declare type TSBaseType = TSAnyKeyword | TSBooleanKeyword | TSBigIntKeyword | TSIntrinsicKeyword | TSNeverKeyword | TSNullKeyword | TSNumberKeyword | TSObjectKeyword | TSStringKeyword | TSSymbolKeyword | TSUndefinedKeyword | TSUnknownKeyword | TSVoidKeyword | TSThisType | TSLiteralType;
export interface Aliases {
	Expression: Expression;
	Binary: Binary;
	Scopable: Scopable;
	BlockParent: BlockParent;
	Block: Block;
	Statement: Statement;
	Terminatorless: Terminatorless;
	CompletionStatement: CompletionStatement;
	Conditional: Conditional;
	Loop: Loop;
	While: While;
	ExpressionWrapper: ExpressionWrapper;
	For: For;
	ForXStatement: ForXStatement;
	Function: Function;
	FunctionParent: FunctionParent;
	Pureish: Pureish;
	Declaration: Declaration;
	PatternLike: PatternLike;
	LVal: LVal;
	TSEntityName: TSEntityName;
	Literal: Literal;
	Immutable: Immutable;
	UserWhitespacable: UserWhitespacable;
	Method: Method;
	ObjectMember: ObjectMember;
	Property: Property;
	UnaryLike: UnaryLike;
	Pattern: Pattern;
	Class: Class;
	ModuleDeclaration: ModuleDeclaration;
	ExportDeclaration: ExportDeclaration;
	ModuleSpecifier: ModuleSpecifier;
	Flow: Flow;
	FlowType: FlowType;
	FlowBaseAnnotation: FlowBaseAnnotation;
	FlowDeclaration: FlowDeclaration;
	FlowPredicate: FlowPredicate;
	EnumBody: EnumBody;
	EnumMember: EnumMember;
	JSX: JSX;
	Private: Private;
	TSTypeElement: TSTypeElement;
	TSType: TSType;
	TSBaseType: TSBaseType;
}
declare function isCompatTag(tagName?: string): boolean;
export declare type ReturnedChild = JSXExpressionContainer | JSXSpreadChild | JSXElement | JSXFragment | Expression;
declare function buildChildren(node: {
	children: ReadonlyArray<JSXText | JSXExpressionContainer | JSXSpreadChild | JSXElement | JSXFragment | JSXEmptyExpression>;
}): ReturnedChild[];
export declare function assertNode(node?: any): asserts node is Node;
export declare function assertArrayExpression(node: object | null | undefined, opts?: object | null): asserts node is ArrayExpression;
export declare function assertAssignmentExpression(node: object | null | undefined, opts?: object | null): asserts node is AssignmentExpression;
export declare function assertBinaryExpression(node: object | null | undefined, opts?: object | null): asserts node is BinaryExpression;
export declare function assertInterpreterDirective(node: object | null | undefined, opts?: object | null): asserts node is InterpreterDirective;
export declare function assertDirective(node: object | null | undefined, opts?: object | null): asserts node is Directive;
export declare function assertDirectiveLiteral(node: object | null | undefined, opts?: object | null): asserts node is DirectiveLiteral;
export declare function assertBlockStatement(node: object | null | undefined, opts?: object | null): asserts node is BlockStatement;
export declare function assertBreakStatement(node: object | null | undefined, opts?: object | null): asserts node is BreakStatement;
export declare function assertCallExpression(node: object | null | undefined, opts?: object | null): asserts node is CallExpression;
export declare function assertCatchClause(node: object | null | undefined, opts?: object | null): asserts node is CatchClause;
export declare function assertConditionalExpression(node: object | null | undefined, opts?: object | null): asserts node is ConditionalExpression;
export declare function assertContinueStatement(node: object | null | undefined, opts?: object | null): asserts node is ContinueStatement;
export declare function assertDebuggerStatement(node: object | null | undefined, opts?: object | null): asserts node is DebuggerStatement;
export declare function assertDoWhileStatement(node: object | null | undefined, opts?: object | null): asserts node is DoWhileStatement;
export declare function assertEmptyStatement(node: object | null | undefined, opts?: object | null): asserts node is EmptyStatement;
export declare function assertExpressionStatement(node: object | null | undefined, opts?: object | null): asserts node is ExpressionStatement;
export declare function assertFile(node: object | null | undefined, opts?: object | null): asserts node is File;
export declare function assertForInStatement(node: object | null | undefined, opts?: object | null): asserts node is ForInStatement;
export declare function assertForStatement(node: object | null | undefined, opts?: object | null): asserts node is ForStatement;
export declare function assertFunctionDeclaration(node: object | null | undefined, opts?: object | null): asserts node is FunctionDeclaration;
export declare function assertFunctionExpression(node: object | null | undefined, opts?: object | null): asserts node is FunctionExpression;
export declare function assertIdentifier(node: object | null | undefined, opts?: object | null): asserts node is Identifier;
export declare function assertIfStatement(node: object | null | undefined, opts?: object | null): asserts node is IfStatement;
export declare function assertLabeledStatement(node: object | null | undefined, opts?: object | null): asserts node is LabeledStatement;
export declare function assertStringLiteral(node: object | null | undefined, opts?: object | null): asserts node is StringLiteral;
export declare function assertNumericLiteral(node: object | null | undefined, opts?: object | null): asserts node is NumericLiteral;
export declare function assertNullLiteral(node: object | null | undefined, opts?: object | null): asserts node is NullLiteral;
export declare function assertBooleanLiteral(node: object | null | undefined, opts?: object | null): asserts node is BooleanLiteral;
export declare function assertRegExpLiteral(node: object | null | undefined, opts?: object | null): asserts node is RegExpLiteral;
export declare function assertLogicalExpression(node: object | null | undefined, opts?: object | null): asserts node is LogicalExpression;
export declare function assertMemberExpression(node: object | null | undefined, opts?: object | null): asserts node is MemberExpression;
export declare function assertNewExpression(node: object | null | undefined, opts?: object | null): asserts node is NewExpression;
export declare function assertProgram(node: object | null | undefined, opts?: object | null): asserts node is Program;
export declare function assertObjectExpression(node: object | null | undefined, opts?: object | null): asserts node is ObjectExpression;
export declare function assertObjectMethod(node: object | null | undefined, opts?: object | null): asserts node is ObjectMethod;
export declare function assertObjectProperty(node: object | null | undefined, opts?: object | null): asserts node is ObjectProperty;
export declare function assertRestElement(node: object | null | undefined, opts?: object | null): asserts node is RestElement;
export declare function assertReturnStatement(node: object | null | undefined, opts?: object | null): asserts node is ReturnStatement;
export declare function assertSequenceExpression(node: object | null | undefined, opts?: object | null): asserts node is SequenceExpression;
export declare function assertParenthesizedExpression(node: object | null | undefined, opts?: object | null): asserts node is ParenthesizedExpression;
export declare function assertSwitchCase(node: object | null | undefined, opts?: object | null): asserts node is SwitchCase;
export declare function assertSwitchStatement(node: object | null | undefined, opts?: object | null): asserts node is SwitchStatement;
export declare function assertThisExpression(node: object | null | undefined, opts?: object | null): asserts node is ThisExpression;
export declare function assertThrowStatement(node: object | null | undefined, opts?: object | null): asserts node is ThrowStatement;
export declare function assertTryStatement(node: object | null | undefined, opts?: object | null): asserts node is TryStatement;
export declare function assertUnaryExpression(node: object | null | undefined, opts?: object | null): asserts node is UnaryExpression;
export declare function assertUpdateExpression(node: object | null | undefined, opts?: object | null): asserts node is UpdateExpression;
export declare function assertVariableDeclaration(node: object | null | undefined, opts?: object | null): asserts node is VariableDeclaration;
export declare function assertVariableDeclarator(node: object | null | undefined, opts?: object | null): asserts node is VariableDeclarator;
export declare function assertWhileStatement(node: object | null | undefined, opts?: object | null): asserts node is WhileStatement;
export declare function assertWithStatement(node: object | null | undefined, opts?: object | null): asserts node is WithStatement;
export declare function assertAssignmentPattern(node: object | null | undefined, opts?: object | null): asserts node is AssignmentPattern;
export declare function assertArrayPattern(node: object | null | undefined, opts?: object | null): asserts node is ArrayPattern;
export declare function assertArrowFunctionExpression(node: object | null | undefined, opts?: object | null): asserts node is ArrowFunctionExpression;
export declare function assertClassBody(node: object | null | undefined, opts?: object | null): asserts node is ClassBody;
export declare function assertClassExpression(node: object | null | undefined, opts?: object | null): asserts node is ClassExpression;
export declare function assertClassDeclaration(node: object | null | undefined, opts?: object | null): asserts node is ClassDeclaration;
export declare function assertExportAllDeclaration(node: object | null | undefined, opts?: object | null): asserts node is ExportAllDeclaration;
export declare function assertExportDefaultDeclaration(node: object | null | undefined, opts?: object | null): asserts node is ExportDefaultDeclaration;
export declare function assertExportNamedDeclaration(node: object | null | undefined, opts?: object | null): asserts node is ExportNamedDeclaration;
export declare function assertExportSpecifier(node: object | null | undefined, opts?: object | null): asserts node is ExportSpecifier;
export declare function assertForOfStatement(node: object | null | undefined, opts?: object | null): asserts node is ForOfStatement;
export declare function assertImportDeclaration(node: object | null | undefined, opts?: object | null): asserts node is ImportDeclaration;
export declare function assertImportDefaultSpecifier(node: object | null | undefined, opts?: object | null): asserts node is ImportDefaultSpecifier;
export declare function assertImportNamespaceSpecifier(node: object | null | undefined, opts?: object | null): asserts node is ImportNamespaceSpecifier;
export declare function assertImportSpecifier(node: object | null | undefined, opts?: object | null): asserts node is ImportSpecifier;
export declare function assertMetaProperty(node: object | null | undefined, opts?: object | null): asserts node is MetaProperty;
export declare function assertClassMethod(node: object | null | undefined, opts?: object | null): asserts node is ClassMethod;
export declare function assertObjectPattern(node: object | null | undefined, opts?: object | null): asserts node is ObjectPattern;
export declare function assertSpreadElement(node: object | null | undefined, opts?: object | null): asserts node is SpreadElement;
export declare function assertSuper(node: object | null | undefined, opts?: object | null): asserts node is Super;
export declare function assertTaggedTemplateExpression(node: object | null | undefined, opts?: object | null): asserts node is TaggedTemplateExpression;
export declare function assertTemplateElement(node: object | null | undefined, opts?: object | null): asserts node is TemplateElement;
export declare function assertTemplateLiteral(node: object | null | undefined, opts?: object | null): asserts node is TemplateLiteral;
export declare function assertYieldExpression(node: object | null | undefined, opts?: object | null): asserts node is YieldExpression;
export declare function assertAwaitExpression(node: object | null | undefined, opts?: object | null): asserts node is AwaitExpression;
export declare function assertImport(node: object | null | undefined, opts?: object | null): asserts node is Import;
export declare function assertBigIntLiteral(node: object | null | undefined, opts?: object | null): asserts node is BigIntLiteral;
export declare function assertExportNamespaceSpecifier(node: object | null | undefined, opts?: object | null): asserts node is ExportNamespaceSpecifier;
export declare function assertOptionalMemberExpression(node: object | null | undefined, opts?: object | null): asserts node is OptionalMemberExpression;
export declare function assertOptionalCallExpression(node: object | null | undefined, opts?: object | null): asserts node is OptionalCallExpression;
export declare function assertAnyTypeAnnotation(node: object | null | undefined, opts?: object | null): asserts node is AnyTypeAnnotation;
export declare function assertArrayTypeAnnotation(node: object | null | undefined, opts?: object | null): asserts node is ArrayTypeAnnotation;
export declare function assertBooleanTypeAnnotation(node: object | null | undefined, opts?: object | null): asserts node is BooleanTypeAnnotation;
export declare function assertBooleanLiteralTypeAnnotation(node: object | null | undefined, opts?: object | null): asserts node is BooleanLiteralTypeAnnotation;
export declare function assertNullLiteralTypeAnnotation(node: object | null | undefined, opts?: object | null): asserts node is NullLiteralTypeAnnotation;
export declare function assertClassImplements(node: object | null | undefined, opts?: object | null): asserts node is ClassImplements;
export declare function assertDeclareClass(node: object | null | undefined, opts?: object | null): asserts node is DeclareClass;
export declare function assertDeclareFunction(node: object | null | undefined, opts?: object | null): asserts node is DeclareFunction;
export declare function assertDeclareInterface(node: object | null | undefined, opts?: object | null): asserts node is DeclareInterface;
export declare function assertDeclareModule(node: object | null | undefined, opts?: object | null): asserts node is DeclareModule;
export declare function assertDeclareModuleExports(node: object | null | undefined, opts?: object | null): asserts node is DeclareModuleExports;
export declare function assertDeclareTypeAlias(node: object | null | undefined, opts?: object | null): asserts node is DeclareTypeAlias;
export declare function assertDeclareOpaqueType(node: object | null | undefined, opts?: object | null): asserts node is DeclareOpaqueType;
export declare function assertDeclareVariable(node: object | null | undefined, opts?: object | null): asserts node is DeclareVariable;
export declare function assertDeclareExportDeclaration(node: object | null | undefined, opts?: object | null): asserts node is DeclareExportDeclaration;
export declare function assertDeclareExportAllDeclaration(node: object | null | undefined, opts?: object | null): asserts node is DeclareExportAllDeclaration;
export declare function assertDeclaredPredicate(node: object | null | undefined, opts?: object | null): asserts node is DeclaredPredicate;
export declare function assertExistsTypeAnnotation(node: object | null | undefined, opts?: object | null): asserts node is ExistsTypeAnnotation;
export declare function assertFunctionTypeAnnotation(node: object | null | undefined, opts?: object | null): asserts node is FunctionTypeAnnotation;
export declare function assertFunctionTypeParam(node: object | null | undefined, opts?: object | null): asserts node is FunctionTypeParam;
export declare function assertGenericTypeAnnotation(node: object | null | undefined, opts?: object | null): asserts node is GenericTypeAnnotation;
export declare function assertInferredPredicate(node: object | null | undefined, opts?: object | null): asserts node is InferredPredicate;
export declare function assertInterfaceExtends(node: object | null | undefined, opts?: object | null): asserts node is InterfaceExtends;
export declare function assertInterfaceDeclaration(node: object | null | undefined, opts?: object | null): asserts node is InterfaceDeclaration;
export declare function assertInterfaceTypeAnnotation(node: object | null | undefined, opts?: object | null): asserts node is InterfaceTypeAnnotation;
export declare function assertIntersectionTypeAnnotation(node: object | null | undefined, opts?: object | null): asserts node is IntersectionTypeAnnotation;
export declare function assertMixedTypeAnnotation(node: object | null | undefined, opts?: object | null): asserts node is MixedTypeAnnotation;
export declare function assertEmptyTypeAnnotation(node: object | null | undefined, opts?: object | null): asserts node is EmptyTypeAnnotation;
export declare function assertNullableTypeAnnotation(node: object | null | undefined, opts?: object | null): asserts node is NullableTypeAnnotation;
export declare function assertNumberLiteralTypeAnnotation(node: object | null | undefined, opts?: object | null): asserts node is NumberLiteralTypeAnnotation;
export declare function assertNumberTypeAnnotation(node: object | null | undefined, opts?: object | null): asserts node is NumberTypeAnnotation;
export declare function assertObjectTypeAnnotation(node: object | null | undefined, opts?: object | null): asserts node is ObjectTypeAnnotation;
export declare function assertObjectTypeInternalSlot(node: object | null | undefined, opts?: object | null): asserts node is ObjectTypeInternalSlot;
export declare function assertObjectTypeCallProperty(node: object | null | undefined, opts?: object | null): asserts node is ObjectTypeCallProperty;
export declare function assertObjectTypeIndexer(node: object | null | undefined, opts?: object | null): asserts node is ObjectTypeIndexer;
export declare function assertObjectTypeProperty(node: object | null | undefined, opts?: object | null): asserts node is ObjectTypeProperty;
export declare function assertObjectTypeSpreadProperty(node: object | null | undefined, opts?: object | null): asserts node is ObjectTypeSpreadProperty;
export declare function assertOpaqueType(node: object | null | undefined, opts?: object | null): asserts node is OpaqueType;
export declare function assertQualifiedTypeIdentifier(node: object | null | undefined, opts?: object | null): asserts node is QualifiedTypeIdentifier;
export declare function assertStringLiteralTypeAnnotation(node: object | null | undefined, opts?: object | null): asserts node is StringLiteralTypeAnnotation;
export declare function assertStringTypeAnnotation(node: object | null | undefined, opts?: object | null): asserts node is StringTypeAnnotation;
export declare function assertSymbolTypeAnnotation(node: object | null | undefined, opts?: object | null): asserts node is SymbolTypeAnnotation;
export declare function assertThisTypeAnnotation(node: object | null | undefined, opts?: object | null): asserts node is ThisTypeAnnotation;
export declare function assertTupleTypeAnnotation(node: object | null | undefined, opts?: object | null): asserts node is TupleTypeAnnotation;
export declare function assertTypeofTypeAnnotation(node: object | null | undefined, opts?: object | null): asserts node is TypeofTypeAnnotation;
export declare function assertTypeAlias(node: object | null | undefined, opts?: object | null): asserts node is TypeAlias;
export declare function assertTypeAnnotation(node: object | null | undefined, opts?: object | null): asserts node is TypeAnnotation;
export declare function assertTypeCastExpression(node: object | null | undefined, opts?: object | null): asserts node is TypeCastExpression;
export declare function assertTypeParameter(node: object | null | undefined, opts?: object | null): asserts node is TypeParameter;
export declare function assertTypeParameterDeclaration(node: object | null | undefined, opts?: object | null): asserts node is TypeParameterDeclaration;
export declare function assertTypeParameterInstantiation(node: object | null | undefined, opts?: object | null): asserts node is TypeParameterInstantiation;
export declare function assertUnionTypeAnnotation(node: object | null | undefined, opts?: object | null): asserts node is UnionTypeAnnotation;
export declare function assertVariance(node: object | null | undefined, opts?: object | null): asserts node is Variance;
export declare function assertVoidTypeAnnotation(node: object | null | undefined, opts?: object | null): asserts node is VoidTypeAnnotation;
export declare function assertEnumDeclaration(node: object | null | undefined, opts?: object | null): asserts node is EnumDeclaration;
export declare function assertEnumBooleanBody(node: object | null | undefined, opts?: object | null): asserts node is EnumBooleanBody;
export declare function assertEnumNumberBody(node: object | null | undefined, opts?: object | null): asserts node is EnumNumberBody;
export declare function assertEnumStringBody(node: object | null | undefined, opts?: object | null): asserts node is EnumStringBody;
export declare function assertEnumSymbolBody(node: object | null | undefined, opts?: object | null): asserts node is EnumSymbolBody;
export declare function assertEnumBooleanMember(node: object | null | undefined, opts?: object | null): asserts node is EnumBooleanMember;
export declare function assertEnumNumberMember(node: object | null | undefined, opts?: object | null): asserts node is EnumNumberMember;
export declare function assertEnumStringMember(node: object | null | undefined, opts?: object | null): asserts node is EnumStringMember;
export declare function assertEnumDefaultedMember(node: object | null | undefined, opts?: object | null): asserts node is EnumDefaultedMember;
export declare function assertJSXAttribute(node: object | null | undefined, opts?: object | null): asserts node is JSXAttribute;
export declare function assertJSXClosingElement(node: object | null | undefined, opts?: object | null): asserts node is JSXClosingElement;
export declare function assertJSXElement(node: object | null | undefined, opts?: object | null): asserts node is JSXElement;
export declare function assertJSXEmptyExpression(node: object | null | undefined, opts?: object | null): asserts node is JSXEmptyExpression;
export declare function assertJSXExpressionContainer(node: object | null | undefined, opts?: object | null): asserts node is JSXExpressionContainer;
export declare function assertJSXSpreadChild(node: object | null | undefined, opts?: object | null): asserts node is JSXSpreadChild;
export declare function assertJSXIdentifier(node: object | null | undefined, opts?: object | null): asserts node is JSXIdentifier;
export declare function assertJSXMemberExpression(node: object | null | undefined, opts?: object | null): asserts node is JSXMemberExpression;
export declare function assertJSXNamespacedName(node: object | null | undefined, opts?: object | null): asserts node is JSXNamespacedName;
export declare function assertJSXOpeningElement(node: object | null | undefined, opts?: object | null): asserts node is JSXOpeningElement;
export declare function assertJSXSpreadAttribute(node: object | null | undefined, opts?: object | null): asserts node is JSXSpreadAttribute;
export declare function assertJSXText(node: object | null | undefined, opts?: object | null): asserts node is JSXText;
export declare function assertJSXFragment(node: object | null | undefined, opts?: object | null): asserts node is JSXFragment;
export declare function assertJSXOpeningFragment(node: object | null | undefined, opts?: object | null): asserts node is JSXOpeningFragment;
export declare function assertJSXClosingFragment(node: object | null | undefined, opts?: object | null): asserts node is JSXClosingFragment;
export declare function assertNoop(node: object | null | undefined, opts?: object | null): asserts node is Noop;
export declare function assertPlaceholder(node: object | null | undefined, opts?: object | null): asserts node is Placeholder;
export declare function assertV8IntrinsicIdentifier(node: object | null | undefined, opts?: object | null): asserts node is V8IntrinsicIdentifier;
export declare function assertArgumentPlaceholder(node: object | null | undefined, opts?: object | null): asserts node is ArgumentPlaceholder;
export declare function assertBindExpression(node: object | null | undefined, opts?: object | null): asserts node is BindExpression;
export declare function assertClassProperty(node: object | null | undefined, opts?: object | null): asserts node is ClassProperty;
export declare function assertPipelineTopicExpression(node: object | null | undefined, opts?: object | null): asserts node is PipelineTopicExpression;
export declare function assertPipelineBareFunction(node: object | null | undefined, opts?: object | null): asserts node is PipelineBareFunction;
export declare function assertPipelinePrimaryTopicReference(node: object | null | undefined, opts?: object | null): asserts node is PipelinePrimaryTopicReference;
export declare function assertClassPrivateProperty(node: object | null | undefined, opts?: object | null): asserts node is ClassPrivateProperty;
export declare function assertClassPrivateMethod(node: object | null | undefined, opts?: object | null): asserts node is ClassPrivateMethod;
export declare function assertImportAttribute(node: object | null | undefined, opts?: object | null): asserts node is ImportAttribute;
export declare function assertDecorator(node: object | null | undefined, opts?: object | null): asserts node is Decorator;
export declare function assertDoExpression(node: object | null | undefined, opts?: object | null): asserts node is DoExpression;
export declare function assertExportDefaultSpecifier(node: object | null | undefined, opts?: object | null): asserts node is ExportDefaultSpecifier;
export declare function assertPrivateName(node: object | null | undefined, opts?: object | null): asserts node is PrivateName;
export declare function assertRecordExpression(node: object | null | undefined, opts?: object | null): asserts node is RecordExpression;
export declare function assertTupleExpression(node: object | null | undefined, opts?: object | null): asserts node is TupleExpression;
export declare function assertDecimalLiteral(node: object | null | undefined, opts?: object | null): asserts node is DecimalLiteral;
export declare function assertStaticBlock(node: object | null | undefined, opts?: object | null): asserts node is StaticBlock;
export declare function assertTSParameterProperty(node: object | null | undefined, opts?: object | null): asserts node is TSParameterProperty;
export declare function assertTSDeclareFunction(node: object | null | undefined, opts?: object | null): asserts node is TSDeclareFunction;
export declare function assertTSDeclareMethod(node: object | null | undefined, opts?: object | null): asserts node is TSDeclareMethod;
export declare function assertTSQualifiedName(node: object | null | undefined, opts?: object | null): asserts node is TSQualifiedName;
export declare function assertTSCallSignatureDeclaration(node: object | null | undefined, opts?: object | null): asserts node is TSCallSignatureDeclaration;
export declare function assertTSConstructSignatureDeclaration(node: object | null | undefined, opts?: object | null): asserts node is TSConstructSignatureDeclaration;
export declare function assertTSPropertySignature(node: object | null | undefined, opts?: object | null): asserts node is TSPropertySignature;
export declare function assertTSMethodSignature(node: object | null | undefined, opts?: object | null): asserts node is TSMethodSignature;
export declare function assertTSIndexSignature(node: object | null | undefined, opts?: object | null): asserts node is TSIndexSignature;
export declare function assertTSAnyKeyword(node: object | null | undefined, opts?: object | null): asserts node is TSAnyKeyword;
export declare function assertTSBooleanKeyword(node: object | null | undefined, opts?: object | null): asserts node is TSBooleanKeyword;
export declare function assertTSBigIntKeyword(node: object | null | undefined, opts?: object | null): asserts node is TSBigIntKeyword;
export declare function assertTSIntrinsicKeyword(node: object | null | undefined, opts?: object | null): asserts node is TSIntrinsicKeyword;
export declare function assertTSNeverKeyword(node: object | null | undefined, opts?: object | null): asserts node is TSNeverKeyword;
export declare function assertTSNullKeyword(node: object | null | undefined, opts?: object | null): asserts node is TSNullKeyword;
export declare function assertTSNumberKeyword(node: object | null | undefined, opts?: object | null): asserts node is TSNumberKeyword;
export declare function assertTSObjectKeyword(node: object | null | undefined, opts?: object | null): asserts node is TSObjectKeyword;
export declare function assertTSStringKeyword(node: object | null | undefined, opts?: object | null): asserts node is TSStringKeyword;
export declare function assertTSSymbolKeyword(node: object | null | undefined, opts?: object | null): asserts node is TSSymbolKeyword;
export declare function assertTSUndefinedKeyword(node: object | null | undefined, opts?: object | null): asserts node is TSUndefinedKeyword;
export declare function assertTSUnknownKeyword(node: object | null | undefined, opts?: object | null): asserts node is TSUnknownKeyword;
export declare function assertTSVoidKeyword(node: object | null | undefined, opts?: object | null): asserts node is TSVoidKeyword;
export declare function assertTSThisType(node: object | null | undefined, opts?: object | null): asserts node is TSThisType;
export declare function assertTSFunctionType(node: object | null | undefined, opts?: object | null): asserts node is TSFunctionType;
export declare function assertTSConstructorType(node: object | null | undefined, opts?: object | null): asserts node is TSConstructorType;
export declare function assertTSTypeReference(node: object | null | undefined, opts?: object | null): asserts node is TSTypeReference;
export declare function assertTSTypePredicate(node: object | null | undefined, opts?: object | null): asserts node is TSTypePredicate;
export declare function assertTSTypeQuery(node: object | null | undefined, opts?: object | null): asserts node is TSTypeQuery;
export declare function assertTSTypeLiteral(node: object | null | undefined, opts?: object | null): asserts node is TSTypeLiteral;
export declare function assertTSArrayType(node: object | null | undefined, opts?: object | null): asserts node is TSArrayType;
export declare function assertTSTupleType(node: object | null | undefined, opts?: object | null): asserts node is TSTupleType;
export declare function assertTSOptionalType(node: object | null | undefined, opts?: object | null): asserts node is TSOptionalType;
export declare function assertTSRestType(node: object | null | undefined, opts?: object | null): asserts node is TSRestType;
export declare function assertTSNamedTupleMember(node: object | null | undefined, opts?: object | null): asserts node is TSNamedTupleMember;
export declare function assertTSUnionType(node: object | null | undefined, opts?: object | null): asserts node is TSUnionType;
export declare function assertTSIntersectionType(node: object | null | undefined, opts?: object | null): asserts node is TSIntersectionType;
export declare function assertTSConditionalType(node: object | null | undefined, opts?: object | null): asserts node is TSConditionalType;
export declare function assertTSInferType(node: object | null | undefined, opts?: object | null): asserts node is TSInferType;
export declare function assertTSParenthesizedType(node: object | null | undefined, opts?: object | null): asserts node is TSParenthesizedType;
export declare function assertTSTypeOperator(node: object | null | undefined, opts?: object | null): asserts node is TSTypeOperator;
export declare function assertTSIndexedAccessType(node: object | null | undefined, opts?: object | null): asserts node is TSIndexedAccessType;
export declare function assertTSMappedType(node: object | null | undefined, opts?: object | null): asserts node is TSMappedType;
export declare function assertTSLiteralType(node: object | null | undefined, opts?: object | null): asserts node is TSLiteralType;
export declare function assertTSExpressionWithTypeArguments(node: object | null | undefined, opts?: object | null): asserts node is TSExpressionWithTypeArguments;
export declare function assertTSInterfaceDeclaration(node: object | null | undefined, opts?: object | null): asserts node is TSInterfaceDeclaration;
export declare function assertTSInterfaceBody(node: object | null | undefined, opts?: object | null): asserts node is TSInterfaceBody;
export declare function assertTSTypeAliasDeclaration(node: object | null | undefined, opts?: object | null): asserts node is TSTypeAliasDeclaration;
export declare function assertTSAsExpression(node: object | null | undefined, opts?: object | null): asserts node is TSAsExpression;
export declare function assertTSTypeAssertion(node: object | null | undefined, opts?: object | null): asserts node is TSTypeAssertion;
export declare function assertTSEnumDeclaration(node: object | null | undefined, opts?: object | null): asserts node is TSEnumDeclaration;
export declare function assertTSEnumMember(node: object | null | undefined, opts?: object | null): asserts node is TSEnumMember;
export declare function assertTSModuleDeclaration(node: object | null | undefined, opts?: object | null): asserts node is TSModuleDeclaration;
export declare function assertTSModuleBlock(node: object | null | undefined, opts?: object | null): asserts node is TSModuleBlock;
export declare function assertTSImportType(node: object | null | undefined, opts?: object | null): asserts node is TSImportType;
export declare function assertTSImportEqualsDeclaration(node: object | null | undefined, opts?: object | null): asserts node is TSImportEqualsDeclaration;
export declare function assertTSExternalModuleReference(node: object | null | undefined, opts?: object | null): asserts node is TSExternalModuleReference;
export declare function assertTSNonNullExpression(node: object | null | undefined, opts?: object | null): asserts node is TSNonNullExpression;
export declare function assertTSExportAssignment(node: object | null | undefined, opts?: object | null): asserts node is TSExportAssignment;
export declare function assertTSNamespaceExportDeclaration(node: object | null | undefined, opts?: object | null): asserts node is TSNamespaceExportDeclaration;
export declare function assertTSTypeAnnotation(node: object | null | undefined, opts?: object | null): asserts node is TSTypeAnnotation;
export declare function assertTSTypeParameterInstantiation(node: object | null | undefined, opts?: object | null): asserts node is TSTypeParameterInstantiation;
export declare function assertTSTypeParameterDeclaration(node: object | null | undefined, opts?: object | null): asserts node is TSTypeParameterDeclaration;
export declare function assertTSTypeParameter(node: object | null | undefined, opts?: object | null): asserts node is TSTypeParameter;
export declare function assertExpression(node: object | null | undefined, opts?: object | null): asserts node is Expression;
export declare function assertBinary(node: object | null | undefined, opts?: object | null): asserts node is Binary;
export declare function assertScopable(node: object | null | undefined, opts?: object | null): asserts node is Scopable;
export declare function assertBlockParent(node: object | null | undefined, opts?: object | null): asserts node is BlockParent;
export declare function assertBlock(node: object | null | undefined, opts?: object | null): asserts node is Block;
export declare function assertStatement(node: object | null | undefined, opts?: object | null): asserts node is Statement;
export declare function assertTerminatorless(node: object | null | undefined, opts?: object | null): asserts node is Terminatorless;
export declare function assertCompletionStatement(node: object | null | undefined, opts?: object | null): asserts node is CompletionStatement;
export declare function assertConditional(node: object | null | undefined, opts?: object | null): asserts node is Conditional;
export declare function assertLoop(node: object | null | undefined, opts?: object | null): asserts node is Loop;
export declare function assertWhile(node: object | null | undefined, opts?: object | null): asserts node is While;
export declare function assertExpressionWrapper(node: object | null | undefined, opts?: object | null): asserts node is ExpressionWrapper;
export declare function assertFor(node: object | null | undefined, opts?: object | null): asserts node is For;
export declare function assertForXStatement(node: object | null | undefined, opts?: object | null): asserts node is ForXStatement;
export declare function assertFunction(node: object | null | undefined, opts?: object | null): asserts node is Function;
export declare function assertFunctionParent(node: object | null | undefined, opts?: object | null): asserts node is FunctionParent;
export declare function assertPureish(node: object | null | undefined, opts?: object | null): asserts node is Pureish;
export declare function assertDeclaration(node: object | null | undefined, opts?: object | null): asserts node is Declaration;
export declare function assertPatternLike(node: object | null | undefined, opts?: object | null): asserts node is PatternLike;
export declare function assertLVal(node: object | null | undefined, opts?: object | null): asserts node is LVal;
export declare function assertTSEntityName(node: object | null | undefined, opts?: object | null): asserts node is TSEntityName;
export declare function assertLiteral(node: object | null | undefined, opts?: object | null): asserts node is Literal;
export declare function assertImmutable(node: object | null | undefined, opts?: object | null): asserts node is Immutable;
export declare function assertUserWhitespacable(node: object | null | undefined, opts?: object | null): asserts node is UserWhitespacable;
export declare function assertMethod(node: object | null | undefined, opts?: object | null): asserts node is Method;
export declare function assertObjectMember(node: object | null | undefined, opts?: object | null): asserts node is ObjectMember;
export declare function assertProperty(node: object | null | undefined, opts?: object | null): asserts node is Property;
export declare function assertUnaryLike(node: object | null | undefined, opts?: object | null): asserts node is UnaryLike;
export declare function assertPattern(node: object | null | undefined, opts?: object | null): asserts node is Pattern;
export declare function assertClass(node: object | null | undefined, opts?: object | null): asserts node is Class;
export declare function assertModuleDeclaration(node: object | null | undefined, opts?: object | null): asserts node is ModuleDeclaration;
export declare function assertExportDeclaration(node: object | null | undefined, opts?: object | null): asserts node is ExportDeclaration;
export declare function assertModuleSpecifier(node: object | null | undefined, opts?: object | null): asserts node is ModuleSpecifier;
export declare function assertFlow(node: object | null | undefined, opts?: object | null): asserts node is Flow;
export declare function assertFlowType(node: object | null | undefined, opts?: object | null): asserts node is FlowType;
export declare function assertFlowBaseAnnotation(node: object | null | undefined, opts?: object | null): asserts node is FlowBaseAnnotation;
export declare function assertFlowDeclaration(node: object | null | undefined, opts?: object | null): asserts node is FlowDeclaration;
export declare function assertFlowPredicate(node: object | null | undefined, opts?: object | null): asserts node is FlowPredicate;
export declare function assertEnumBody(node: object | null | undefined, opts?: object | null): asserts node is EnumBody;
export declare function assertEnumMember(node: object | null | undefined, opts?: object | null): asserts node is EnumMember;
export declare function assertJSX(node: object | null | undefined, opts?: object | null): asserts node is JSX;
export declare function assertPrivate(node: object | null | undefined, opts?: object | null): asserts node is Private;
export declare function assertTSTypeElement(node: object | null | undefined, opts?: object | null): asserts node is TSTypeElement;
export declare function assertTSType(node: object | null | undefined, opts?: object | null): asserts node is TSType;
export declare function assertTSBaseType(node: object | null | undefined, opts?: object | null): asserts node is TSBaseType;
export declare function assertNumberLiteral(node: any, opts: any): void;
export declare function assertRegexLiteral(node: any, opts: any): void;
export declare function assertRestProperty(node: any, opts: any): void;
export declare function assertSpreadProperty(node: any, opts: any): void;
/**
 * Create a type annotation based on typeof expression.
 */
export declare function createTypeAnnotationBasedOnTypeof(type: "string" | "number" | "undefined" | "boolean" | "function" | "object" | "symbol"): StringTypeAnnotation | VoidTypeAnnotation | NumberTypeAnnotation | BooleanTypeAnnotation | GenericTypeAnnotation;
/**
 * Takes an array of `types` and flattens them, removing duplicates and
 * returns a `UnionTypeAnnotation` node containing them.
 */
export declare function createFlowUnionType<T extends FlowType>(types: [
	T
] | Array<T>): T | UnionTypeAnnotation;
/**
 * Takes an array of `types` and flattens them, removing duplicates and
 * returns a `UnionTypeAnnotation` node containing them.
 */
export declare function createTSUnionType(typeAnnotations: Array<TSTypeAnnotation>): TSType;
export declare function arrayExpression(elements?: Array<null | Expression | SpreadElement>): ArrayExpression;
export declare function assignmentExpression(operator: string, left: LVal, right: Expression): AssignmentExpression;
export declare function binaryExpression(operator: "+" | "-" | "/" | "%" | "*" | "**" | "&" | "|" | ">>" | ">>>" | "<<" | "^" | "==" | "===" | "!=" | "!==" | "in" | "instanceof" | ">" | "<" | ">=" | "<=", left: Expression | PrivateName, right: Expression): BinaryExpression;
export declare function interpreterDirective(value: string): InterpreterDirective;
export declare function directive(value: DirectiveLiteral): Directive;
export declare function directiveLiteral(value: string): DirectiveLiteral;
export declare function blockStatement(body: Array<Statement>, directives?: Array<Directive>): BlockStatement;
export declare function breakStatement(label?: Identifier | null): BreakStatement;
export declare function callExpression(callee: Expression | V8IntrinsicIdentifier, _arguments: Array<Expression | SpreadElement | JSXNamespacedName | ArgumentPlaceholder>): CallExpression;
export declare function catchClause(param: Identifier | ArrayPattern | ObjectPattern | null | undefined, body: BlockStatement): CatchClause;
export declare function conditionalExpression(test: Expression, consequent: Expression, alternate: Expression): ConditionalExpression;
export declare function continueStatement(label?: Identifier | null): ContinueStatement;
export declare function debuggerStatement(): DebuggerStatement;
export declare function doWhileStatement(test: Expression, body: Statement): DoWhileStatement;
export declare function emptyStatement(): EmptyStatement;
export declare function expressionStatement(expression: Expression): ExpressionStatement;
export declare function file(program: Program, comments?: Array<CommentBlock | CommentLine> | null, tokens?: Array<any> | null): File;
export declare function forInStatement(left: VariableDeclaration | LVal, right: Expression, body: Statement): ForInStatement;
export declare function forStatement(init: VariableDeclaration | Expression | null | undefined, test: Expression | null | undefined, update: Expression | null | undefined, body: Statement): ForStatement;
export declare function functionDeclaration(id: Identifier | null | undefined, params: Array<Identifier | Pattern | RestElement | TSParameterProperty>, body: BlockStatement, generator?: boolean, async?: boolean): FunctionDeclaration;
export declare function functionExpression(id: Identifier | null | undefined, params: Array<Identifier | Pattern | RestElement | TSParameterProperty>, body: BlockStatement, generator?: boolean, async?: boolean): FunctionExpression;
export declare function identifier(name: string): Identifier;
export declare function ifStatement(test: Expression, consequent: Statement, alternate?: Statement | null): IfStatement;
export declare function labeledStatement(label: Identifier, body: Statement): LabeledStatement;
export declare function stringLiteral(value: string): StringLiteral;
export declare function numericLiteral(value: number): NumericLiteral;
export declare function nullLiteral(): NullLiteral;
export declare function booleanLiteral(value: boolean): BooleanLiteral;
export declare function regExpLiteral(pattern: string, flags?: string): RegExpLiteral;
export declare function logicalExpression(operator: "||" | "&&" | "??", left: Expression, right: Expression): LogicalExpression;
export declare function memberExpression(object: Expression, property: Expression | Identifier | PrivateName, computed?: boolean, optional?: true | false | null): MemberExpression;
export declare function newExpression(callee: Expression | V8IntrinsicIdentifier, _arguments: Array<Expression | SpreadElement | JSXNamespacedName | ArgumentPlaceholder>): NewExpression;
export declare function program(body: Array<Statement>, directives?: Array<Directive>, sourceType?: "script" | "module", interpreter?: InterpreterDirective | null): Program;
export declare function objectExpression(properties: Array<ObjectMethod | ObjectProperty | SpreadElement>): ObjectExpression;
export declare function objectMethod(kind: "method" | "get" | "set" | undefined, key: Expression | Identifier | StringLiteral | NumericLiteral, params: Array<Identifier | Pattern | RestElement | TSParameterProperty>, body: BlockStatement, computed?: boolean, generator?: boolean, async?: boolean): ObjectMethod;
export declare function objectProperty(key: Expression | Identifier | StringLiteral | NumericLiteral, value: Expression | PatternLike, computed?: boolean, shorthand?: boolean, decorators?: Array<Decorator> | null): ObjectProperty;
export declare function restElement(argument: LVal): RestElement;
export declare function returnStatement(argument?: Expression | null): ReturnStatement;
export declare function sequenceExpression(expressions: Array<Expression>): SequenceExpression;
export declare function parenthesizedExpression(expression: Expression): ParenthesizedExpression;
export declare function switchCase(test: Expression | null | undefined, consequent: Array<Statement>): SwitchCase;
export declare function switchStatement(discriminant: Expression, cases: Array<SwitchCase>): SwitchStatement;
export declare function thisExpression(): ThisExpression;
export declare function throwStatement(argument: Expression): ThrowStatement;
export declare function tryStatement(block: BlockStatement, handler?: CatchClause | null, finalizer?: BlockStatement | null): TryStatement;
export declare function unaryExpression(operator: "void" | "throw" | "delete" | "!" | "+" | "-" | "~" | "typeof", argument: Expression, prefix?: boolean): UnaryExpression;
export declare function updateExpression(operator: "++" | "--", argument: Expression, prefix?: boolean): UpdateExpression;
export declare function variableDeclaration(kind: "var" | "let" | "const", declarations: Array<VariableDeclarator>): VariableDeclaration;
export declare function variableDeclarator(id: LVal, init?: Expression | null): VariableDeclarator;
export declare function whileStatement(test: Expression, body: Statement): WhileStatement;
export declare function withStatement(object: Expression, body: Statement): WithStatement;
export declare function assignmentPattern(left: Identifier | ObjectPattern | ArrayPattern | MemberExpression, right: Expression): AssignmentPattern;
export declare function arrayPattern(elements: Array<null | PatternLike>): ArrayPattern;
export declare function arrowFunctionExpression(params: Array<Identifier | Pattern | RestElement | TSParameterProperty>, body: BlockStatement | Expression, async?: boolean): ArrowFunctionExpression;
export declare function classBody(body: Array<ClassMethod | ClassPrivateMethod | ClassProperty | ClassPrivateProperty | TSDeclareMethod | TSIndexSignature>): ClassBody;
export declare function classExpression(id: Identifier | null | undefined, superClass: Expression | null | undefined, body: ClassBody, decorators?: Array<Decorator> | null): ClassExpression;
export declare function classDeclaration(id: Identifier, superClass: Expression | null | undefined, body: ClassBody, decorators?: Array<Decorator> | null): ClassDeclaration;
export declare function exportAllDeclaration(source: StringLiteral): ExportAllDeclaration;
export declare function exportDefaultDeclaration(declaration: FunctionDeclaration | TSDeclareFunction | ClassDeclaration | Expression): ExportDefaultDeclaration;
export declare function exportNamedDeclaration(declaration?: Declaration | null, specifiers?: Array<ExportSpecifier | ExportDefaultSpecifier | ExportNamespaceSpecifier>, source?: StringLiteral | null): ExportNamedDeclaration;
export declare function exportSpecifier(local: Identifier, exported: Identifier | StringLiteral): ExportSpecifier;
export declare function forOfStatement(left: VariableDeclaration | LVal, right: Expression, body: Statement, _await?: boolean): ForOfStatement;
export declare function importDeclaration(specifiers: Array<ImportSpecifier | ImportDefaultSpecifier | ImportNamespaceSpecifier>, source: StringLiteral): ImportDeclaration;
export declare function importDefaultSpecifier(local: Identifier): ImportDefaultSpecifier;
export declare function importNamespaceSpecifier(local: Identifier): ImportNamespaceSpecifier;
export declare function importSpecifier(local: Identifier, imported: Identifier | StringLiteral): ImportSpecifier;
export declare function metaProperty(meta: Identifier, property: Identifier): MetaProperty;
export declare function classMethod(kind: "get" | "set" | "method" | "constructor" | undefined, key: Identifier | StringLiteral | NumericLiteral | Expression, params: Array<Identifier | Pattern | RestElement | TSParameterProperty>, body: BlockStatement, computed?: boolean, _static?: boolean, generator?: boolean, async?: boolean): ClassMethod;
export declare function objectPattern(properties: Array<RestElement | ObjectProperty>): ObjectPattern;
export declare function spreadElement(argument: Expression): SpreadElement;
declare function _super(): Super;
export declare function taggedTemplateExpression(tag: Expression, quasi: TemplateLiteral): TaggedTemplateExpression;
export declare function templateElement(value: {
	raw: string;
	cooked?: string;
}, tail?: boolean): TemplateElement;
export declare function templateLiteral(quasis: Array<TemplateElement>, expressions: Array<Expression | TSType>): TemplateLiteral;
export declare function yieldExpression(argument?: Expression | null, delegate?: boolean): YieldExpression;
export declare function awaitExpression(argument: Expression): AwaitExpression;
declare function _import(): Import;
export declare function bigIntLiteral(value: string): BigIntLiteral;
export declare function exportNamespaceSpecifier(exported: Identifier): ExportNamespaceSpecifier;
export declare function optionalMemberExpression(object: Expression, property: Expression | Identifier, computed: boolean | undefined, optional: boolean): OptionalMemberExpression;
export declare function optionalCallExpression(callee: Expression, _arguments: Array<Expression | SpreadElement | JSXNamespacedName | ArgumentPlaceholder>, optional: boolean): OptionalCallExpression;
export declare function anyTypeAnnotation(): AnyTypeAnnotation;
export declare function arrayTypeAnnotation(elementType: FlowType): ArrayTypeAnnotation;
export declare function booleanTypeAnnotation(): BooleanTypeAnnotation;
export declare function booleanLiteralTypeAnnotation(value: boolean): BooleanLiteralTypeAnnotation;
export declare function nullLiteralTypeAnnotation(): NullLiteralTypeAnnotation;
export declare function classImplements(id: Identifier, typeParameters?: TypeParameterInstantiation | null): ClassImplements;
export declare function declareClass(id: Identifier, typeParameters: TypeParameterDeclaration | null | undefined, _extends: Array<InterfaceExtends> | null | undefined, body: ObjectTypeAnnotation): DeclareClass;
export declare function declareFunction(id: Identifier): DeclareFunction;
export declare function declareInterface(id: Identifier, typeParameters: TypeParameterDeclaration | null | undefined, _extends: Array<InterfaceExtends> | null | undefined, body: ObjectTypeAnnotation): DeclareInterface;
export declare function declareModule(id: Identifier | StringLiteral, body: BlockStatement, kind?: "CommonJS" | "ES" | null): DeclareModule;
export declare function declareModuleExports(typeAnnotation: TypeAnnotation): DeclareModuleExports;
export declare function declareTypeAlias(id: Identifier, typeParameters: TypeParameterDeclaration | null | undefined, right: FlowType): DeclareTypeAlias;
export declare function declareOpaqueType(id: Identifier, typeParameters?: TypeParameterDeclaration | null, supertype?: FlowType | null): DeclareOpaqueType;
export declare function declareVariable(id: Identifier): DeclareVariable;
export declare function declareExportDeclaration(declaration?: Flow | null, specifiers?: Array<ExportSpecifier | ExportNamespaceSpecifier> | null, source?: StringLiteral | null): DeclareExportDeclaration;
export declare function declareExportAllDeclaration(source: StringLiteral): DeclareExportAllDeclaration;
export declare function declaredPredicate(value: Flow): DeclaredPredicate;
export declare function existsTypeAnnotation(): ExistsTypeAnnotation;
export declare function functionTypeAnnotation(typeParameters: TypeParameterDeclaration | null | undefined, params: Array<FunctionTypeParam>, rest: FunctionTypeParam | null | undefined, returnType: FlowType): FunctionTypeAnnotation;
export declare function functionTypeParam(name: Identifier | null | undefined, typeAnnotation: FlowType): FunctionTypeParam;
export declare function genericTypeAnnotation(id: Identifier | QualifiedTypeIdentifier, typeParameters?: TypeParameterInstantiation | null): GenericTypeAnnotation;
export declare function inferredPredicate(): InferredPredicate;
export declare function interfaceExtends(id: Identifier | QualifiedTypeIdentifier, typeParameters?: TypeParameterInstantiation | null): InterfaceExtends;
export declare function interfaceDeclaration(id: Identifier, typeParameters: TypeParameterDeclaration | null | undefined, _extends: Array<InterfaceExtends> | null | undefined, body: ObjectTypeAnnotation): InterfaceDeclaration;
export declare function interfaceTypeAnnotation(_extends: Array<InterfaceExtends> | null | undefined, body: ObjectTypeAnnotation): InterfaceTypeAnnotation;
export declare function intersectionTypeAnnotation(types: Array<FlowType>): IntersectionTypeAnnotation;
export declare function mixedTypeAnnotation(): MixedTypeAnnotation;
export declare function emptyTypeAnnotation(): EmptyTypeAnnotation;
export declare function nullableTypeAnnotation(typeAnnotation: FlowType): NullableTypeAnnotation;
export declare function numberLiteralTypeAnnotation(value: number): NumberLiteralTypeAnnotation;
export declare function numberTypeAnnotation(): NumberTypeAnnotation;
export declare function objectTypeAnnotation(properties: Array<ObjectTypeProperty | ObjectTypeSpreadProperty>, indexers?: Array<ObjectTypeIndexer> | null, callProperties?: Array<ObjectTypeCallProperty> | null, internalSlots?: Array<ObjectTypeInternalSlot> | null, exact?: boolean): ObjectTypeAnnotation;
export declare function objectTypeInternalSlot(id: Identifier, value: FlowType, optional: boolean, _static: boolean, method: boolean): ObjectTypeInternalSlot;
export declare function objectTypeCallProperty(value: FlowType): ObjectTypeCallProperty;
export declare function objectTypeIndexer(id: Identifier | null | undefined, key: FlowType, value: FlowType, variance?: Variance | null): ObjectTypeIndexer;
export declare function objectTypeProperty(key: Identifier | StringLiteral, value: FlowType, variance?: Variance | null): ObjectTypeProperty;
export declare function objectTypeSpreadProperty(argument: FlowType): ObjectTypeSpreadProperty;
export declare function opaqueType(id: Identifier, typeParameters: TypeParameterDeclaration | null | undefined, supertype: FlowType | null | undefined, impltype: FlowType): OpaqueType;
export declare function qualifiedTypeIdentifier(id: Identifier, qualification: Identifier | QualifiedTypeIdentifier): QualifiedTypeIdentifier;
export declare function stringLiteralTypeAnnotation(value: string): StringLiteralTypeAnnotation;
export declare function stringTypeAnnotation(): StringTypeAnnotation;
export declare function symbolTypeAnnotation(): SymbolTypeAnnotation;
export declare function thisTypeAnnotation(): ThisTypeAnnotation;
export declare function tupleTypeAnnotation(types: Array<FlowType>): TupleTypeAnnotation;
export declare function typeofTypeAnnotation(argument: FlowType): TypeofTypeAnnotation;
export declare function typeAlias(id: Identifier, typeParameters: TypeParameterDeclaration | null | undefined, right: FlowType): TypeAlias;
export declare function typeAnnotation(typeAnnotation: FlowType): TypeAnnotation;
export declare function typeCastExpression(expression: Expression, typeAnnotation: TypeAnnotation): TypeCastExpression;
export declare function typeParameter(bound?: TypeAnnotation | null, _default?: FlowType | null, variance?: Variance | null): TypeParameter;
export declare function typeParameterDeclaration(params: Array<TypeParameter>): TypeParameterDeclaration;
export declare function typeParameterInstantiation(params: Array<FlowType>): TypeParameterInstantiation;
export declare function unionTypeAnnotation(types: Array<FlowType>): UnionTypeAnnotation;
export declare function variance(kind: "minus" | "plus"): Variance;
export declare function voidTypeAnnotation(): VoidTypeAnnotation;
export declare function enumDeclaration(id: Identifier, body: EnumBooleanBody | EnumNumberBody | EnumStringBody | EnumSymbolBody): EnumDeclaration;
export declare function enumBooleanBody(members: Array<EnumBooleanMember>): EnumBooleanBody;
export declare function enumNumberBody(members: Array<EnumNumberMember>): EnumNumberBody;
export declare function enumStringBody(members: Array<EnumStringMember | EnumDefaultedMember>): EnumStringBody;
export declare function enumSymbolBody(members: Array<EnumDefaultedMember>): EnumSymbolBody;
export declare function enumBooleanMember(id: Identifier): EnumBooleanMember;
export declare function enumNumberMember(id: Identifier, init: NumericLiteral): EnumNumberMember;
export declare function enumStringMember(id: Identifier, init: StringLiteral): EnumStringMember;
export declare function enumDefaultedMember(id: Identifier): EnumDefaultedMember;
export declare function jsxAttribute(name: JSXIdentifier | JSXNamespacedName, value?: JSXElement | JSXFragment | StringLiteral | JSXExpressionContainer | null): JSXAttribute;
export declare function jsxClosingElement(name: JSXIdentifier | JSXMemberExpression | JSXNamespacedName): JSXClosingElement;
export declare function jsxElement(openingElement: JSXOpeningElement, closingElement: JSXClosingElement | null | undefined, children: Array<JSXText | JSXExpressionContainer | JSXSpreadChild | JSXElement | JSXFragment>, selfClosing?: boolean | null): JSXElement;
export declare function jsxEmptyExpression(): JSXEmptyExpression;
export declare function jsxExpressionContainer(expression: Expression | JSXEmptyExpression): JSXExpressionContainer;
export declare function jsxSpreadChild(expression: Expression): JSXSpreadChild;
export declare function jsxIdentifier(name: string): JSXIdentifier;
export declare function jsxMemberExpression(object: JSXMemberExpression | JSXIdentifier, property: JSXIdentifier): JSXMemberExpression;
export declare function jsxNamespacedName(namespace: JSXIdentifier, name: JSXIdentifier): JSXNamespacedName;
export declare function jsxOpeningElement(name: JSXIdentifier | JSXMemberExpression | JSXNamespacedName, attributes: Array<JSXAttribute | JSXSpreadAttribute>, selfClosing?: boolean): JSXOpeningElement;
export declare function jsxSpreadAttribute(argument: Expression): JSXSpreadAttribute;
export declare function jsxText(value: string): JSXText;
export declare function jsxFragment(openingFragment: JSXOpeningFragment, closingFragment: JSXClosingFragment, children: Array<JSXText | JSXExpressionContainer | JSXSpreadChild | JSXElement | JSXFragment>): JSXFragment;
export declare function jsxOpeningFragment(): JSXOpeningFragment;
export declare function jsxClosingFragment(): JSXClosingFragment;
export declare function noop(): Noop;
export declare function placeholder(expectedNode: "Identifier" | "StringLiteral" | "Expression" | "Statement" | "Declaration" | "BlockStatement" | "ClassBody" | "Pattern", name: Identifier): Placeholder;
export declare function v8IntrinsicIdentifier(name: string): V8IntrinsicIdentifier;
export declare function argumentPlaceholder(): ArgumentPlaceholder;
export declare function bindExpression(object: Expression, callee: Expression): BindExpression;
export declare function classProperty(key: Identifier | StringLiteral | NumericLiteral | Expression, value?: Expression | null, typeAnnotation?: TypeAnnotation | TSTypeAnnotation | Noop | null, decorators?: Array<Decorator> | null, computed?: boolean, _static?: boolean): ClassProperty;
export declare function pipelineTopicExpression(expression: Expression): PipelineTopicExpression;
export declare function pipelineBareFunction(callee: Expression): PipelineBareFunction;
export declare function pipelinePrimaryTopicReference(): PipelinePrimaryTopicReference;
export declare function classPrivateProperty(key: PrivateName, value: Expression | null | undefined, decorators: Array<Decorator> | null | undefined, _static: any): ClassPrivateProperty;
export declare function classPrivateMethod(kind: "get" | "set" | "method" | "constructor" | undefined, key: PrivateName, params: Array<Identifier | Pattern | RestElement | TSParameterProperty>, body: BlockStatement, _static?: boolean): ClassPrivateMethod;
export declare function importAttribute(key: Identifier | StringLiteral, value: StringLiteral): ImportAttribute;
export declare function decorator(expression: Expression): Decorator;
export declare function doExpression(body: BlockStatement): DoExpression;
export declare function exportDefaultSpecifier(exported: Identifier): ExportDefaultSpecifier;
export declare function privateName(id: Identifier): PrivateName;
export declare function recordExpression(properties: Array<ObjectProperty | SpreadElement>): RecordExpression;
export declare function tupleExpression(elements?: Array<Expression | SpreadElement>): TupleExpression;
export declare function decimalLiteral(value: string): DecimalLiteral;
export declare function staticBlock(body: Array<Statement>): StaticBlock;
export declare function tsParameterProperty(parameter: Identifier | AssignmentPattern): TSParameterProperty;
export declare function tsDeclareFunction(id: Identifier | null | undefined, typeParameters: TSTypeParameterDeclaration | Noop | null | undefined, params: Array<Identifier | Pattern | RestElement | TSParameterProperty>, returnType?: TSTypeAnnotation | Noop | null): TSDeclareFunction;
export declare function tsDeclareMethod(decorators: Array<Decorator> | null | undefined, key: Identifier | StringLiteral | NumericLiteral | Expression, typeParameters: TSTypeParameterDeclaration | Noop | null | undefined, params: Array<Identifier | Pattern | RestElement | TSParameterProperty>, returnType?: TSTypeAnnotation | Noop | null): TSDeclareMethod;
export declare function tsQualifiedName(left: TSEntityName, right: Identifier): TSQualifiedName;
export declare function tsCallSignatureDeclaration(typeParameters: TSTypeParameterDeclaration | null | undefined, parameters: Array<Identifier | RestElement>, typeAnnotation?: TSTypeAnnotation | null): TSCallSignatureDeclaration;
export declare function tsConstructSignatureDeclaration(typeParameters: TSTypeParameterDeclaration | null | undefined, parameters: Array<Identifier | RestElement>, typeAnnotation?: TSTypeAnnotation | null): TSConstructSignatureDeclaration;
export declare function tsPropertySignature(key: Expression, typeAnnotation?: TSTypeAnnotation | null, initializer?: Expression | null): TSPropertySignature;
export declare function tsMethodSignature(key: Expression, typeParameters: TSTypeParameterDeclaration | null | undefined, parameters: Array<Identifier | RestElement>, typeAnnotation?: TSTypeAnnotation | null): TSMethodSignature;
export declare function tsIndexSignature(parameters: Array<Identifier>, typeAnnotation?: TSTypeAnnotation | null): TSIndexSignature;
export declare function tsAnyKeyword(): TSAnyKeyword;
export declare function tsBooleanKeyword(): TSBooleanKeyword;
export declare function tsBigIntKeyword(): TSBigIntKeyword;
export declare function tsIntrinsicKeyword(): TSIntrinsicKeyword;
export declare function tsNeverKeyword(): TSNeverKeyword;
export declare function tsNullKeyword(): TSNullKeyword;
export declare function tsNumberKeyword(): TSNumberKeyword;
export declare function tsObjectKeyword(): TSObjectKeyword;
export declare function tsStringKeyword(): TSStringKeyword;
export declare function tsSymbolKeyword(): TSSymbolKeyword;
export declare function tsUndefinedKeyword(): TSUndefinedKeyword;
export declare function tsUnknownKeyword(): TSUnknownKeyword;
export declare function tsVoidKeyword(): TSVoidKeyword;
export declare function tsThisType(): TSThisType;
export declare function tsFunctionType(typeParameters: TSTypeParameterDeclaration | null | undefined, parameters: Array<Identifier | RestElement>, typeAnnotation?: TSTypeAnnotation | null): TSFunctionType;
export declare function tsConstructorType(typeParameters: TSTypeParameterDeclaration | null | undefined, parameters: Array<Identifier | RestElement>, typeAnnotation?: TSTypeAnnotation | null): TSConstructorType;
export declare function tsTypeReference(typeName: TSEntityName, typeParameters?: TSTypeParameterInstantiation | null): TSTypeReference;
export declare function tsTypePredicate(parameterName: Identifier | TSThisType, typeAnnotation?: TSTypeAnnotation | null, asserts?: boolean | null): TSTypePredicate;
export declare function tsTypeQuery(exprName: TSEntityName | TSImportType): TSTypeQuery;
export declare function tsTypeLiteral(members: Array<TSTypeElement>): TSTypeLiteral;
export declare function tsArrayType(elementType: TSType): TSArrayType;
export declare function tsTupleType(elementTypes: Array<TSType | TSNamedTupleMember>): TSTupleType;
export declare function tsOptionalType(typeAnnotation: TSType): TSOptionalType;
export declare function tsRestType(typeAnnotation: TSType): TSRestType;
export declare function tsNamedTupleMember(label: Identifier, elementType: TSType, optional?: boolean): TSNamedTupleMember;
export declare function tsUnionType(types: Array<TSType>): TSUnionType;
export declare function tsIntersectionType(types: Array<TSType>): TSIntersectionType;
export declare function tsConditionalType(checkType: TSType, extendsType: TSType, trueType: TSType, falseType: TSType): TSConditionalType;
export declare function tsInferType(typeParameter: TSTypeParameter): TSInferType;
export declare function tsParenthesizedType(typeAnnotation: TSType): TSParenthesizedType;
export declare function tsTypeOperator(typeAnnotation: TSType): TSTypeOperator;
export declare function tsIndexedAccessType(objectType: TSType, indexType: TSType): TSIndexedAccessType;
export declare function tsMappedType(typeParameter: TSTypeParameter, typeAnnotation?: TSType | null, nameType?: TSType | null): TSMappedType;
export declare function tsLiteralType(literal: NumericLiteral | StringLiteral | BooleanLiteral | BigIntLiteral): TSLiteralType;
export declare function tsExpressionWithTypeArguments(expression: TSEntityName, typeParameters?: TSTypeParameterInstantiation | null): TSExpressionWithTypeArguments;
export declare function tsInterfaceDeclaration(id: Identifier, typeParameters: TSTypeParameterDeclaration | null | undefined, _extends: Array<TSExpressionWithTypeArguments> | null | undefined, body: TSInterfaceBody): TSInterfaceDeclaration;
export declare function tsInterfaceBody(body: Array<TSTypeElement>): TSInterfaceBody;
export declare function tsTypeAliasDeclaration(id: Identifier, typeParameters: TSTypeParameterDeclaration | null | undefined, typeAnnotation: TSType): TSTypeAliasDeclaration;
export declare function tsAsExpression(expression: Expression, typeAnnotation: TSType): TSAsExpression;
export declare function tsTypeAssertion(typeAnnotation: TSType, expression: Expression): TSTypeAssertion;
export declare function tsEnumDeclaration(id: Identifier, members: Array<TSEnumMember>): TSEnumDeclaration;
export declare function tsEnumMember(id: Identifier | StringLiteral, initializer?: Expression | null): TSEnumMember;
export declare function tsModuleDeclaration(id: Identifier | StringLiteral, body: TSModuleBlock | TSModuleDeclaration): TSModuleDeclaration;
export declare function tsModuleBlock(body: Array<Statement>): TSModuleBlock;
export declare function tsImportType(argument: StringLiteral, qualifier?: TSEntityName | null, typeParameters?: TSTypeParameterInstantiation | null): TSImportType;
export declare function tsImportEqualsDeclaration(id: Identifier, moduleReference: TSEntityName | TSExternalModuleReference): TSImportEqualsDeclaration;
export declare function tsExternalModuleReference(expression: StringLiteral): TSExternalModuleReference;
export declare function tsNonNullExpression(expression: Expression): TSNonNullExpression;
export declare function tsExportAssignment(expression: Expression): TSExportAssignment;
export declare function tsNamespaceExportDeclaration(id: Identifier): TSNamespaceExportDeclaration;
export declare function tsTypeAnnotation(typeAnnotation: TSType): TSTypeAnnotation;
export declare function tsTypeParameterInstantiation(params: Array<TSType>): TSTypeParameterInstantiation;
export declare function tsTypeParameterDeclaration(params: Array<TSTypeParameter>): TSTypeParameterDeclaration;
export declare function tsTypeParameter(constraint: TSType | null | undefined, _default: TSType | null | undefined, name: string): TSTypeParameter;
declare function NumberLiteral$1(...args: Array<any>): any;
declare function RegexLiteral$1(...args: Array<any>): any;
declare function RestProperty$1(...args: Array<any>): any;
declare function SpreadProperty$1(...args: Array<any>): any;
/**
 * Create a clone of a `node` including only properties belonging to the node.
 * If the second parameter is `false`, cloneNode performs a shallow clone.
 * If the third parameter is true, the cloned nodes exclude location properties.
 */
export declare function cloneNode<T extends Node>(node: T, deep?: boolean, withoutLoc?: boolean): T;
/**
 * Create a shallow clone of a `node`, including only
 * properties belonging to the node.
 * @deprecated Use t.cloneNode instead.
 */
export declare function clone<T extends Node>(node: T): T;
/**
 * Create a deep clone of a `node` and all of it's child nodes
 * including only properties belonging to the node.
 * @deprecated Use t.cloneNode instead.
 */
export declare function cloneDeep<T extends Node>(node: T): T;
/**
 * Create a deep clone of a `node` and all of it's child nodes
 * including only properties belonging to the node.
 * excluding `_private` and location properties.
 */
export declare function cloneDeepWithoutLoc<T extends Node>(node: T): T;
/**
 * Create a shallow clone of a `node` excluding `_private` and location properties.
 */
export declare function cloneWithoutLoc<T extends Node>(node: T): T;
/**
 * Add comment of certain type to a node.
 */
export declare function addComment<T extends Node>(node: T, type: CommentTypeShorthand, content: string, line?: boolean): T;
/**
 * Add comments of certain type to a node.
 */
export declare function addComments<T extends Node>(node: T, type: CommentTypeShorthand, comments: ReadonlyArray<Comment>): T;
export declare function inheritInnerComments(child: Node, parent: Node): void;
export declare function inheritLeadingComments(child: Node, parent: Node): void;
/**
 * Inherit all unique comments from `parent` node to `child` node.
 */
export declare function inheritsComments<T extends Node>(child: T, parent: Node): T;
export declare function inheritTrailingComments(child: Node, parent: Node): void;
/**
 * Remove comment properties from a node.
 */
export declare function removeComments<T extends Node>(node: T): T;
export declare const EXPRESSION_TYPES: string[];
export declare const BINARY_TYPES: string[];
export declare const SCOPABLE_TYPES: string[];
export declare const BLOCKPARENT_TYPES: string[];
export declare const BLOCK_TYPES: string[];
export declare const STATEMENT_TYPES: string[];
export declare const TERMINATORLESS_TYPES: string[];
export declare const COMPLETIONSTATEMENT_TYPES: string[];
export declare const CONDITIONAL_TYPES: string[];
export declare const LOOP_TYPES: string[];
export declare const WHILE_TYPES: string[];
export declare const EXPRESSIONWRAPPER_TYPES: string[];
export declare const FOR_TYPES: string[];
export declare const FORXSTATEMENT_TYPES: string[];
export declare const FUNCTION_TYPES: string[];
export declare const FUNCTIONPARENT_TYPES: string[];
export declare const PUREISH_TYPES: string[];
export declare const DECLARATION_TYPES: string[];
export declare const PATTERNLIKE_TYPES: string[];
export declare const LVAL_TYPES: string[];
export declare const TSENTITYNAME_TYPES: string[];
export declare const LITERAL_TYPES: string[];
export declare const IMMUTABLE_TYPES: string[];
export declare const USERWHITESPACABLE_TYPES: string[];
export declare const METHOD_TYPES: string[];
export declare const OBJECTMEMBER_TYPES: string[];
export declare const PROPERTY_TYPES: string[];
export declare const UNARYLIKE_TYPES: string[];
export declare const PATTERN_TYPES: string[];
export declare const CLASS_TYPES: string[];
export declare const MODULEDECLARATION_TYPES: string[];
export declare const EXPORTDECLARATION_TYPES: string[];
export declare const MODULESPECIFIER_TYPES: string[];
export declare const FLOW_TYPES: string[];
export declare const FLOWTYPE_TYPES: string[];
export declare const FLOWBASEANNOTATION_TYPES: string[];
export declare const FLOWDECLARATION_TYPES: string[];
export declare const FLOWPREDICATE_TYPES: string[];
export declare const ENUMBODY_TYPES: string[];
export declare const ENUMMEMBER_TYPES: string[];
export declare const JSX_TYPES: string[];
export declare const PRIVATE_TYPES: string[];
export declare const TSTYPEELEMENT_TYPES: string[];
export declare const TSTYPE_TYPES: string[];
export declare const TSBASETYPE_TYPES: string[];
export declare const STATEMENT_OR_BLOCK_KEYS: string[];
export declare const FLATTENABLE_KEYS: string[];
export declare const FOR_INIT_KEYS: string[];
export declare const COMMENT_KEYS: string[];
export declare const LOGICAL_OPERATORS: string[];
export declare const UPDATE_OPERATORS: string[];
export declare const BOOLEAN_NUMBER_BINARY_OPERATORS: string[];
export declare const EQUALITY_BINARY_OPERATORS: string[];
export declare const COMPARISON_BINARY_OPERATORS: string[];
export declare const BOOLEAN_BINARY_OPERATORS: string[];
export declare const NUMBER_BINARY_OPERATORS: string[];
export declare const BINARY_OPERATORS: string[];
export declare const ASSIGNMENT_OPERATORS: string[];
export declare const BOOLEAN_UNARY_OPERATORS: string[];
export declare const NUMBER_UNARY_OPERATORS: string[];
export declare const STRING_UNARY_OPERATORS: string[];
export declare const UNARY_OPERATORS: string[];
export declare const INHERIT_KEYS: {
	optional: string[];
	force: string[];
};
export declare const BLOCK_SCOPED_SYMBOL: unique symbol;
export declare const NOT_LOCAL_BINDING: unique symbol;
/**
 * Ensure the `key` (defaults to "body") of a `node` is a block.
 * Casting it to a block if it is not.
 *
 * Returns the BlockStatement
 */
export declare function ensureBlock(node: Node, key?: string): BlockStatement;
export declare function toBindingIdentifierName(name: string): string;
export declare function toBlock(node: Statement | Expression, parent?: Node): BlockStatement;
export declare function toComputedKey(node: ObjectMember | ObjectProperty | ClassMethod | ClassProperty | MemberExpression | OptionalMemberExpression, key?: Expression): Expression;
declare const _default: {
	(node: Function): FunctionExpression;
	(node: Class): ClassExpression;
	(node: ExpressionStatement | Expression | Class | Function): Expression;
};
export declare function toIdentifier(name: string): string;
export declare function toKeyAlias(node: Method | Property, key?: Node): string;
export declare namespace toKeyAlias {
	var uid: number;
	var increment: () => number;
}
export declare type Scope = {
	push(value: {
		id: LVal;
		kind: "var";
		init?: Expression;
	}): void;
	buildUndefinedNode(): Node;
};
/**
 * Turn an array of statement `nodes` into a `SequenceExpression`.
 *
 * Variable declarations are turned into simple assignments and their
 * declarations hoisted to the top of the current scope.
 *
 * Expression statements are just resolved to their expression.
 */
export declare function toSequenceExpression(nodes: ReadonlyArray<Node>, scope: Scope): SequenceExpression | undefined;
declare const _default$1: {
	(node: AssignmentExpression, ignore?: boolean): ExpressionStatement;
	<T extends Statement>(node: T, ignore: false): T;
	<T_1 extends Statement>(node: T_1, ignore?: boolean): false | T_1;
	(node: Class, ignore: false): ClassDeclaration;
	(node: Class, ignore?: boolean): ClassDeclaration | false;
	(node: Function, ignore: false): FunctionDeclaration;
	(node: Function, ignore?: boolean): FunctionDeclaration | false;
	(node: Node, ignore: false): Statement;
	(node: Node, ignore?: boolean): Statement | false;
};
declare const _default$2: {
	(value: undefined): Identifier;
	(value: boolean): BooleanLiteral;
	(value: null): NullLiteral;
	(value: string): StringLiteral;
	(value: number): NumericLiteral | BinaryExpression | UnaryExpression;
	(value: RegExp): RegExpLiteral;
	(value: ReadonlyArray<unknown>): ArrayExpression;
	(value: object): ObjectExpression;
	(value: unknown): Expression;
};
export declare const VISITOR_KEYS: Record<string, string[]>;
export declare const ALIAS_KEYS: Record<string, string[]>;
export declare const FLIPPED_ALIAS_KEYS: Record<string, string[]>;
export declare const NODE_FIELDS: Record<string, {}>;
export declare const BUILDER_KEYS: Record<string, string[]>;
export declare const DEPRECATED_KEYS: Record<string, string>;
export declare const NODE_PARENT_VALIDATIONS: {};
export declare const PLACEHOLDERS: string[];
export declare const PLACEHOLDERS_ALIAS: Record<string, string[]>;
export declare const PLACEHOLDERS_FLIPPED_ALIAS: Record<string, string[]>;
export declare const TYPES: Array<string>;
/**
 * Append a node to a member expression.
 */
export declare function appendToMemberExpression(member: MemberExpression, append: MemberExpression["property"], computed?: boolean): MemberExpression;
/**
 * Inherit all contextual properties from `parent` node to `child` node.
 */
export declare function inherits<T extends Node | null | undefined>(child: T, parent: Node | null | undefined): T;
/**
 * Prepend a node to a member expression.
 */
export declare function prependToMemberExpression<T extends Pick<MemberExpression, "object" | "property">>(member: T, prepend: MemberExpression["object"]): T;
/**
 * Remove all of the _* properties from a node along with the additional metadata
 * properties like location data and raw token data.
 */
export declare function removeProperties(node: Node, opts?: {
	preserveComments?: boolean;
}): void;
export declare function removePropertiesDeep<T extends Node>(tree: T, opts?: {
	preserveComments: boolean;
} | null): T;
/**
 * Dedupe type annotations.
 */
export declare function removeTypeDuplicates(nodes: ReadonlyArray<FlowType | false | null | undefined>): FlowType[];
export declare function getBindingIdentifiers(node: Node, duplicates: true, outerOnly?: boolean): Record<string, Array<Identifier>>;
export declare namespace getBindingIdentifiers {
	var keys: {
		DeclareClass: string[];
		DeclareFunction: string[];
		DeclareModule: string[];
		DeclareVariable: string[];
		DeclareInterface: string[];
		DeclareTypeAlias: string[];
		DeclareOpaqueType: string[];
		InterfaceDeclaration: string[];
		TypeAlias: string[];
		OpaqueType: string[];
		CatchClause: string[];
		LabeledStatement: string[];
		UnaryExpression: string[];
		AssignmentExpression: string[];
		ImportSpecifier: string[];
		ImportNamespaceSpecifier: string[];
		ImportDefaultSpecifier: string[];
		ImportDeclaration: string[];
		ExportSpecifier: string[];
		ExportNamespaceSpecifier: string[];
		ExportDefaultSpecifier: string[];
		FunctionDeclaration: string[];
		FunctionExpression: string[];
		ArrowFunctionExpression: string[];
		ObjectMethod: string[];
		ClassMethod: string[];
		ForInStatement: string[];
		ForOfStatement: string[];
		ClassDeclaration: string[];
		ClassExpression: string[];
		RestElement: string[];
		UpdateExpression: string[];
		ObjectProperty: string[];
		AssignmentPattern: string[];
		ArrayPattern: string[];
		ObjectPattern: string[];
		VariableDeclaration: string[];
		VariableDeclarator: string[];
	};
}
export declare function getBindingIdentifiers(node: Node, duplicates?: false, outerOnly?: boolean): Record<string, Identifier>;
export declare namespace getBindingIdentifiers {
	var keys: {
		DeclareClass: string[];
		DeclareFunction: string[];
		DeclareModule: string[];
		DeclareVariable: string[];
		DeclareInterface: string[];
		DeclareTypeAlias: string[];
		DeclareOpaqueType: string[];
		InterfaceDeclaration: string[];
		TypeAlias: string[];
		OpaqueType: string[];
		CatchClause: string[];
		LabeledStatement: string[];
		UnaryExpression: string[];
		AssignmentExpression: string[];
		ImportSpecifier: string[];
		ImportNamespaceSpecifier: string[];
		ImportDefaultSpecifier: string[];
		ImportDeclaration: string[];
		ExportSpecifier: string[];
		ExportNamespaceSpecifier: string[];
		ExportDefaultSpecifier: string[];
		FunctionDeclaration: string[];
		FunctionExpression: string[];
		ArrowFunctionExpression: string[];
		ObjectMethod: string[];
		ClassMethod: string[];
		ForInStatement: string[];
		ForOfStatement: string[];
		ClassDeclaration: string[];
		ClassExpression: string[];
		RestElement: string[];
		UpdateExpression: string[];
		ObjectProperty: string[];
		AssignmentPattern: string[];
		ArrayPattern: string[];
		ObjectPattern: string[];
		VariableDeclaration: string[];
		VariableDeclarator: string[];
	};
}
export declare function getBindingIdentifiers(node: Node, duplicates?: boolean, outerOnly?: boolean): Record<string, Identifier> | Record<string, Array<Identifier>>;
export declare namespace getBindingIdentifiers {
	var keys: {
		DeclareClass: string[];
		DeclareFunction: string[];
		DeclareModule: string[];
		DeclareVariable: string[];
		DeclareInterface: string[];
		DeclareTypeAlias: string[];
		DeclareOpaqueType: string[];
		InterfaceDeclaration: string[];
		TypeAlias: string[];
		OpaqueType: string[];
		CatchClause: string[];
		LabeledStatement: string[];
		UnaryExpression: string[];
		AssignmentExpression: string[];
		ImportSpecifier: string[];
		ImportNamespaceSpecifier: string[];
		ImportDefaultSpecifier: string[];
		ImportDeclaration: string[];
		ExportSpecifier: string[];
		ExportNamespaceSpecifier: string[];
		ExportDefaultSpecifier: string[];
		FunctionDeclaration: string[];
		FunctionExpression: string[];
		ArrowFunctionExpression: string[];
		ObjectMethod: string[];
		ClassMethod: string[];
		ForInStatement: string[];
		ForOfStatement: string[];
		ClassDeclaration: string[];
		ClassExpression: string[];
		RestElement: string[];
		UpdateExpression: string[];
		ObjectProperty: string[];
		AssignmentPattern: string[];
		ArrayPattern: string[];
		ObjectPattern: string[];
		VariableDeclaration: string[];
		VariableDeclarator: string[];
	};
}
declare const _default$3: {
	(node: Node, duplicates: true): Record<string, Array<Identifier>>;
	(node: Node, duplicates?: false): Record<string, Identifier>;
	(node: Node, duplicates?: boolean): Record<string, Identifier> | Record<string, Array<Identifier>>;
};
export declare type TraversalAncestors = Array<{
	node: Node;
	key: string;
	index?: number;
}>;
export declare type TraversalHandler<T> = (this: undefined, node: Node, parent: TraversalAncestors, state: T) => void;
export declare type TraversalHandlers<T> = {
	enter?: TraversalHandler<T>;
	exit?: TraversalHandler<T>;
};
/**
 * A general AST traversal with both prefix and postfix handlers, and a
 * state object. Exposes ancestry data to each handler so that more complex
 * AST data can be taken into account.
 */
export declare function traverse<T>(node: Node, handlers: TraversalHandler<T> | TraversalHandlers<T>, state?: T): void;
/**
 * A prefix AST traversal implementation meant for simple searching
 * and processing.
 */
export declare function traverseFast(node: Node | null | undefined, enter: (node: Node, opts?: any) => void, opts?: any): void;
export declare function shallowEqual<T extends object>(actual: object, expected: T): actual is T;
export declare function is<T extends Node["type"]>(type: T, node: Node | null | undefined, opts?: undefined): node is Extract<Node, {
	type: T;
}>;
export declare function is<T extends Node["type"], P extends Extract<Node, {
	type: T;
}>>(type: T, n: Node | null | undefined, required: Partial<P>): n is P;
export declare function is<P extends Node>(type: string, node: Node | null | undefined, opts: Partial<P>): node is P;
export declare function is(type: string, node: Node | null | undefined, opts?: Partial<Node>): node is Node;
/**
 * Check if the input `node` is a binding identifier.
 */
export declare function isBinding(node: Node, parent: Node, grandparent?: Node): boolean;
/**
 * Check if the input `node` is block scoped.
 */
export declare function isBlockScoped(node: Node): boolean;
/**
 * Check if the input `node` is definitely immutable.
 */
export declare function isImmutable(node: Node): boolean;
/**
 * Check if the input `node` is a `let` variable declaration.
 */
export declare function isLet(node: Node): boolean;
export declare function isNode(node: any): node is Node;
/**
 * Check if two nodes are equivalent
 */
export declare function isNodesEquivalent<T extends Partial<Node>>(a: T, b: any): b is T;
/**
 * Test if a `placeholderType` is a `targetType` or if `targetType` is an alias of `placeholderType`.
 */
export declare function isPlaceholderType(placeholderType: string, targetType: string): boolean;
/**
 * Check if the input `node` is a reference to a bound variable.
 */
export declare function isReferenced(node: Node, parent: Node, grandparent?: Node): boolean;
/**
 * Check if the input `node` is a scope.
 */
export declare function isScope(node: Node, parent: Node): boolean;
/**
 * Check if the input `specifier` is a `default` import or export.
 */
export declare function isSpecifierDefault(specifier: ModuleSpecifier): boolean;
export declare function isType<T extends Node["type"]>(nodeType: string, targetType: T): nodeType is T;
export declare function isType(nodeType: string | null | undefined, targetType: string): boolean;
/**
 * Check if the input `name` is a valid identifier name according to the ES3 specification.
 *
 * Additional ES3 reserved words are
 */
export declare function isValidES3Identifier(name: string): boolean;
/**
 * Check if the input `name` is a valid identifier name
 * and isn't a reserved word.
 */
export declare function isValidIdentifier(name: string, reserved?: boolean): boolean;
/**
 * Check if the input `node` is a variable declaration.
 */
export declare function isVar(node: Node): boolean;
/**
 * Determines whether or not the input node `member` matches the
 * input `match`.
 *
 * For example, given the match `React.createClass` it would match the
 * parsed nodes of `React.createClass` and `React["createClass"]`.
 */
export declare function matchesPattern(member: Node | null | undefined, match: string | string[], allowPartial?: boolean): boolean;
export declare function validate(node: Node | undefined | null, key: string, val: any): void;
/**
 * Build a function that when called will return whether or not the
 * input `node` `MemberExpression` matches the input `match`.
 *
 * For example, given the match `React.createClass` it would match the
 * parsed nodes of `React.createClass` and `React["createClass"]`.
 */
export declare function buildMatchMemberExpression(match: string, allowPartial?: boolean): (member: Node) => boolean;
export declare function isArrayExpression(node: object | null | undefined, opts?: object | null): node is ArrayExpression;
export declare function isAssignmentExpression(node: object | null | undefined, opts?: object | null): node is AssignmentExpression;
export declare function isBinaryExpression(node: object | null | undefined, opts?: object | null): node is BinaryExpression;
export declare function isInterpreterDirective(node: object | null | undefined, opts?: object | null): node is InterpreterDirective;
export declare function isDirective(node: object | null | undefined, opts?: object | null): node is Directive;
export declare function isDirectiveLiteral(node: object | null | undefined, opts?: object | null): node is DirectiveLiteral;
export declare function isBlockStatement(node: object | null | undefined, opts?: object | null): node is BlockStatement;
export declare function isBreakStatement(node: object | null | undefined, opts?: object | null): node is BreakStatement;
export declare function isCallExpression(node: object | null | undefined, opts?: object | null): node is CallExpression;
export declare function isCatchClause(node: object | null | undefined, opts?: object | null): node is CatchClause;
export declare function isConditionalExpression(node: object | null | undefined, opts?: object | null): node is ConditionalExpression;
export declare function isContinueStatement(node: object | null | undefined, opts?: object | null): node is ContinueStatement;
export declare function isDebuggerStatement(node: object | null | undefined, opts?: object | null): node is DebuggerStatement;
export declare function isDoWhileStatement(node: object | null | undefined, opts?: object | null): node is DoWhileStatement;
export declare function isEmptyStatement(node: object | null | undefined, opts?: object | null): node is EmptyStatement;
export declare function isExpressionStatement(node: object | null | undefined, opts?: object | null): node is ExpressionStatement;
export declare function isFile(node: object | null | undefined, opts?: object | null): node is File;
export declare function isForInStatement(node: object | null | undefined, opts?: object | null): node is ForInStatement;
export declare function isForStatement(node: object | null | undefined, opts?: object | null): node is ForStatement;
export declare function isFunctionDeclaration(node: object | null | undefined, opts?: object | null): node is FunctionDeclaration;
export declare function isFunctionExpression(node: object | null | undefined, opts?: object | null): node is FunctionExpression;
export declare function isIdentifier(node: object | null | undefined, opts?: object | null): node is Identifier;
export declare function isIfStatement(node: object | null | undefined, opts?: object | null): node is IfStatement;
export declare function isLabeledStatement(node: object | null | undefined, opts?: object | null): node is LabeledStatement;
export declare function isStringLiteral(node: object | null | undefined, opts?: object | null): node is StringLiteral;
export declare function isNumericLiteral(node: object | null | undefined, opts?: object | null): node is NumericLiteral;
export declare function isNullLiteral(node: object | null | undefined, opts?: object | null): node is NullLiteral;
export declare function isBooleanLiteral(node: object | null | undefined, opts?: object | null): node is BooleanLiteral;
export declare function isRegExpLiteral(node: object | null | undefined, opts?: object | null): node is RegExpLiteral;
export declare function isLogicalExpression(node: object | null | undefined, opts?: object | null): node is LogicalExpression;
export declare function isMemberExpression(node: object | null | undefined, opts?: object | null): node is MemberExpression;
export declare function isNewExpression(node: object | null | undefined, opts?: object | null): node is NewExpression;
export declare function isProgram(node: object | null | undefined, opts?: object | null): node is Program;
export declare function isObjectExpression(node: object | null | undefined, opts?: object | null): node is ObjectExpression;
export declare function isObjectMethod(node: object | null | undefined, opts?: object | null): node is ObjectMethod;
export declare function isObjectProperty(node: object | null | undefined, opts?: object | null): node is ObjectProperty;
export declare function isRestElement(node: object | null | undefined, opts?: object | null): node is RestElement;
export declare function isReturnStatement(node: object | null | undefined, opts?: object | null): node is ReturnStatement;
export declare function isSequenceExpression(node: object | null | undefined, opts?: object | null): node is SequenceExpression;
export declare function isParenthesizedExpression(node: object | null | undefined, opts?: object | null): node is ParenthesizedExpression;
export declare function isSwitchCase(node: object | null | undefined, opts?: object | null): node is SwitchCase;
export declare function isSwitchStatement(node: object | null | undefined, opts?: object | null): node is SwitchStatement;
export declare function isThisExpression(node: object | null | undefined, opts?: object | null): node is ThisExpression;
export declare function isThrowStatement(node: object | null | undefined, opts?: object | null): node is ThrowStatement;
export declare function isTryStatement(node: object | null | undefined, opts?: object | null): node is TryStatement;
export declare function isUnaryExpression(node: object | null | undefined, opts?: object | null): node is UnaryExpression;
export declare function isUpdateExpression(node: object | null | undefined, opts?: object | null): node is UpdateExpression;
export declare function isVariableDeclaration(node: object | null | undefined, opts?: object | null): node is VariableDeclaration;
export declare function isVariableDeclarator(node: object | null | undefined, opts?: object | null): node is VariableDeclarator;
export declare function isWhileStatement(node: object | null | undefined, opts?: object | null): node is WhileStatement;
export declare function isWithStatement(node: object | null | undefined, opts?: object | null): node is WithStatement;
export declare function isAssignmentPattern(node: object | null | undefined, opts?: object | null): node is AssignmentPattern;
export declare function isArrayPattern(node: object | null | undefined, opts?: object | null): node is ArrayPattern;
export declare function isArrowFunctionExpression(node: object | null | undefined, opts?: object | null): node is ArrowFunctionExpression;
export declare function isClassBody(node: object | null | undefined, opts?: object | null): node is ClassBody;
export declare function isClassExpression(node: object | null | undefined, opts?: object | null): node is ClassExpression;
export declare function isClassDeclaration(node: object | null | undefined, opts?: object | null): node is ClassDeclaration;
export declare function isExportAllDeclaration(node: object | null | undefined, opts?: object | null): node is ExportAllDeclaration;
export declare function isExportDefaultDeclaration(node: object | null | undefined, opts?: object | null): node is ExportDefaultDeclaration;
export declare function isExportNamedDeclaration(node: object | null | undefined, opts?: object | null): node is ExportNamedDeclaration;
export declare function isExportSpecifier(node: object | null | undefined, opts?: object | null): node is ExportSpecifier;
export declare function isForOfStatement(node: object | null | undefined, opts?: object | null): node is ForOfStatement;
export declare function isImportDeclaration(node: object | null | undefined, opts?: object | null): node is ImportDeclaration;
export declare function isImportDefaultSpecifier(node: object | null | undefined, opts?: object | null): node is ImportDefaultSpecifier;
export declare function isImportNamespaceSpecifier(node: object | null | undefined, opts?: object | null): node is ImportNamespaceSpecifier;
export declare function isImportSpecifier(node: object | null | undefined, opts?: object | null): node is ImportSpecifier;
export declare function isMetaProperty(node: object | null | undefined, opts?: object | null): node is MetaProperty;
export declare function isClassMethod(node: object | null | undefined, opts?: object | null): node is ClassMethod;
export declare function isObjectPattern(node: object | null | undefined, opts?: object | null): node is ObjectPattern;
export declare function isSpreadElement(node: object | null | undefined, opts?: object | null): node is SpreadElement;
export declare function isSuper(node: object | null | undefined, opts?: object | null): node is Super;
export declare function isTaggedTemplateExpression(node: object | null | undefined, opts?: object | null): node is TaggedTemplateExpression;
export declare function isTemplateElement(node: object | null | undefined, opts?: object | null): node is TemplateElement;
export declare function isTemplateLiteral(node: object | null | undefined, opts?: object | null): node is TemplateLiteral;
export declare function isYieldExpression(node: object | null | undefined, opts?: object | null): node is YieldExpression;
export declare function isAwaitExpression(node: object | null | undefined, opts?: object | null): node is AwaitExpression;
export declare function isImport(node: object | null | undefined, opts?: object | null): node is Import;
export declare function isBigIntLiteral(node: object | null | undefined, opts?: object | null): node is BigIntLiteral;
export declare function isExportNamespaceSpecifier(node: object | null | undefined, opts?: object | null): node is ExportNamespaceSpecifier;
export declare function isOptionalMemberExpression(node: object | null | undefined, opts?: object | null): node is OptionalMemberExpression;
export declare function isOptionalCallExpression(node: object | null | undefined, opts?: object | null): node is OptionalCallExpression;
export declare function isAnyTypeAnnotation(node: object | null | undefined, opts?: object | null): node is AnyTypeAnnotation;
export declare function isArrayTypeAnnotation(node: object | null | undefined, opts?: object | null): node is ArrayTypeAnnotation;
export declare function isBooleanTypeAnnotation(node: object | null | undefined, opts?: object | null): node is BooleanTypeAnnotation;
export declare function isBooleanLiteralTypeAnnotation(node: object | null | undefined, opts?: object | null): node is BooleanLiteralTypeAnnotation;
export declare function isNullLiteralTypeAnnotation(node: object | null | undefined, opts?: object | null): node is NullLiteralTypeAnnotation;
export declare function isClassImplements(node: object | null | undefined, opts?: object | null): node is ClassImplements;
export declare function isDeclareClass(node: object | null | undefined, opts?: object | null): node is DeclareClass;
export declare function isDeclareFunction(node: object | null | undefined, opts?: object | null): node is DeclareFunction;
export declare function isDeclareInterface(node: object | null | undefined, opts?: object | null): node is DeclareInterface;
export declare function isDeclareModule(node: object | null | undefined, opts?: object | null): node is DeclareModule;
export declare function isDeclareModuleExports(node: object | null | undefined, opts?: object | null): node is DeclareModuleExports;
export declare function isDeclareTypeAlias(node: object | null | undefined, opts?: object | null): node is DeclareTypeAlias;
export declare function isDeclareOpaqueType(node: object | null | undefined, opts?: object | null): node is DeclareOpaqueType;
export declare function isDeclareVariable(node: object | null | undefined, opts?: object | null): node is DeclareVariable;
export declare function isDeclareExportDeclaration(node: object | null | undefined, opts?: object | null): node is DeclareExportDeclaration;
export declare function isDeclareExportAllDeclaration(node: object | null | undefined, opts?: object | null): node is DeclareExportAllDeclaration;
export declare function isDeclaredPredicate(node: object | null | undefined, opts?: object | null): node is DeclaredPredicate;
export declare function isExistsTypeAnnotation(node: object | null | undefined, opts?: object | null): node is ExistsTypeAnnotation;
export declare function isFunctionTypeAnnotation(node: object | null | undefined, opts?: object | null): node is FunctionTypeAnnotation;
export declare function isFunctionTypeParam(node: object | null | undefined, opts?: object | null): node is FunctionTypeParam;
export declare function isGenericTypeAnnotation(node: object | null | undefined, opts?: object | null): node is GenericTypeAnnotation;
export declare function isInferredPredicate(node: object | null | undefined, opts?: object | null): node is InferredPredicate;
export declare function isInterfaceExtends(node: object | null | undefined, opts?: object | null): node is InterfaceExtends;
export declare function isInterfaceDeclaration(node: object | null | undefined, opts?: object | null): node is InterfaceDeclaration;
export declare function isInterfaceTypeAnnotation(node: object | null | undefined, opts?: object | null): node is InterfaceTypeAnnotation;
export declare function isIntersectionTypeAnnotation(node: object | null | undefined, opts?: object | null): node is IntersectionTypeAnnotation;
export declare function isMixedTypeAnnotation(node: object | null | undefined, opts?: object | null): node is MixedTypeAnnotation;
export declare function isEmptyTypeAnnotation(node: object | null | undefined, opts?: object | null): node is EmptyTypeAnnotation;
export declare function isNullableTypeAnnotation(node: object | null | undefined, opts?: object | null): node is NullableTypeAnnotation;
export declare function isNumberLiteralTypeAnnotation(node: object | null | undefined, opts?: object | null): node is NumberLiteralTypeAnnotation;
export declare function isNumberTypeAnnotation(node: object | null | undefined, opts?: object | null): node is NumberTypeAnnotation;
export declare function isObjectTypeAnnotation(node: object | null | undefined, opts?: object | null): node is ObjectTypeAnnotation;
export declare function isObjectTypeInternalSlot(node: object | null | undefined, opts?: object | null): node is ObjectTypeInternalSlot;
export declare function isObjectTypeCallProperty(node: object | null | undefined, opts?: object | null): node is ObjectTypeCallProperty;
export declare function isObjectTypeIndexer(node: object | null | undefined, opts?: object | null): node is ObjectTypeIndexer;
export declare function isObjectTypeProperty(node: object | null | undefined, opts?: object | null): node is ObjectTypeProperty;
export declare function isObjectTypeSpreadProperty(node: object | null | undefined, opts?: object | null): node is ObjectTypeSpreadProperty;
export declare function isOpaqueType(node: object | null | undefined, opts?: object | null): node is OpaqueType;
export declare function isQualifiedTypeIdentifier(node: object | null | undefined, opts?: object | null): node is QualifiedTypeIdentifier;
export declare function isStringLiteralTypeAnnotation(node: object | null | undefined, opts?: object | null): node is StringLiteralTypeAnnotation;
export declare function isStringTypeAnnotation(node: object | null | undefined, opts?: object | null): node is StringTypeAnnotation;
export declare function isSymbolTypeAnnotation(node: object | null | undefined, opts?: object | null): node is SymbolTypeAnnotation;
export declare function isThisTypeAnnotation(node: object | null | undefined, opts?: object | null): node is ThisTypeAnnotation;
export declare function isTupleTypeAnnotation(node: object | null | undefined, opts?: object | null): node is TupleTypeAnnotation;
export declare function isTypeofTypeAnnotation(node: object | null | undefined, opts?: object | null): node is TypeofTypeAnnotation;
export declare function isTypeAlias(node: object | null | undefined, opts?: object | null): node is TypeAlias;
export declare function isTypeAnnotation(node: object | null | undefined, opts?: object | null): node is TypeAnnotation;
export declare function isTypeCastExpression(node: object | null | undefined, opts?: object | null): node is TypeCastExpression;
export declare function isTypeParameter(node: object | null | undefined, opts?: object | null): node is TypeParameter;
export declare function isTypeParameterDeclaration(node: object | null | undefined, opts?: object | null): node is TypeParameterDeclaration;
export declare function isTypeParameterInstantiation(node: object | null | undefined, opts?: object | null): node is TypeParameterInstantiation;
export declare function isUnionTypeAnnotation(node: object | null | undefined, opts?: object | null): node is UnionTypeAnnotation;
export declare function isVariance(node: object | null | undefined, opts?: object | null): node is Variance;
export declare function isVoidTypeAnnotation(node: object | null | undefined, opts?: object | null): node is VoidTypeAnnotation;
export declare function isEnumDeclaration(node: object | null | undefined, opts?: object | null): node is EnumDeclaration;
export declare function isEnumBooleanBody(node: object | null | undefined, opts?: object | null): node is EnumBooleanBody;
export declare function isEnumNumberBody(node: object | null | undefined, opts?: object | null): node is EnumNumberBody;
export declare function isEnumStringBody(node: object | null | undefined, opts?: object | null): node is EnumStringBody;
export declare function isEnumSymbolBody(node: object | null | undefined, opts?: object | null): node is EnumSymbolBody;
export declare function isEnumBooleanMember(node: object | null | undefined, opts?: object | null): node is EnumBooleanMember;
export declare function isEnumNumberMember(node: object | null | undefined, opts?: object | null): node is EnumNumberMember;
export declare function isEnumStringMember(node: object | null | undefined, opts?: object | null): node is EnumStringMember;
export declare function isEnumDefaultedMember(node: object | null | undefined, opts?: object | null): node is EnumDefaultedMember;
export declare function isJSXAttribute(node: object | null | undefined, opts?: object | null): node is JSXAttribute;
export declare function isJSXClosingElement(node: object | null | undefined, opts?: object | null): node is JSXClosingElement;
export declare function isJSXElement(node: object | null | undefined, opts?: object | null): node is JSXElement;
export declare function isJSXEmptyExpression(node: object | null | undefined, opts?: object | null): node is JSXEmptyExpression;
export declare function isJSXExpressionContainer(node: object | null | undefined, opts?: object | null): node is JSXExpressionContainer;
export declare function isJSXSpreadChild(node: object | null | undefined, opts?: object | null): node is JSXSpreadChild;
export declare function isJSXIdentifier(node: object | null | undefined, opts?: object | null): node is JSXIdentifier;
export declare function isJSXMemberExpression(node: object | null | undefined, opts?: object | null): node is JSXMemberExpression;
export declare function isJSXNamespacedName(node: object | null | undefined, opts?: object | null): node is JSXNamespacedName;
export declare function isJSXOpeningElement(node: object | null | undefined, opts?: object | null): node is JSXOpeningElement;
export declare function isJSXSpreadAttribute(node: object | null | undefined, opts?: object | null): node is JSXSpreadAttribute;
export declare function isJSXText(node: object | null | undefined, opts?: object | null): node is JSXText;
export declare function isJSXFragment(node: object | null | undefined, opts?: object | null): node is JSXFragment;
export declare function isJSXOpeningFragment(node: object | null | undefined, opts?: object | null): node is JSXOpeningFragment;
export declare function isJSXClosingFragment(node: object | null | undefined, opts?: object | null): node is JSXClosingFragment;
export declare function isNoop(node: object | null | undefined, opts?: object | null): node is Noop;
export declare function isPlaceholder(node: object | null | undefined, opts?: object | null): node is Placeholder;
export declare function isV8IntrinsicIdentifier(node: object | null | undefined, opts?: object | null): node is V8IntrinsicIdentifier;
export declare function isArgumentPlaceholder(node: object | null | undefined, opts?: object | null): node is ArgumentPlaceholder;
export declare function isBindExpression(node: object | null | undefined, opts?: object | null): node is BindExpression;
export declare function isClassProperty(node: object | null | undefined, opts?: object | null): node is ClassProperty;
export declare function isPipelineTopicExpression(node: object | null | undefined, opts?: object | null): node is PipelineTopicExpression;
export declare function isPipelineBareFunction(node: object | null | undefined, opts?: object | null): node is PipelineBareFunction;
export declare function isPipelinePrimaryTopicReference(node: object | null | undefined, opts?: object | null): node is PipelinePrimaryTopicReference;
export declare function isClassPrivateProperty(node: object | null | undefined, opts?: object | null): node is ClassPrivateProperty;
export declare function isClassPrivateMethod(node: object | null | undefined, opts?: object | null): node is ClassPrivateMethod;
export declare function isImportAttribute(node: object | null | undefined, opts?: object | null): node is ImportAttribute;
export declare function isDecorator(node: object | null | undefined, opts?: object | null): node is Decorator;
export declare function isDoExpression(node: object | null | undefined, opts?: object | null): node is DoExpression;
export declare function isExportDefaultSpecifier(node: object | null | undefined, opts?: object | null): node is ExportDefaultSpecifier;
export declare function isPrivateName(node: object | null | undefined, opts?: object | null): node is PrivateName;
export declare function isRecordExpression(node: object | null | undefined, opts?: object | null): node is RecordExpression;
export declare function isTupleExpression(node: object | null | undefined, opts?: object | null): node is TupleExpression;
export declare function isDecimalLiteral(node: object | null | undefined, opts?: object | null): node is DecimalLiteral;
export declare function isStaticBlock(node: object | null | undefined, opts?: object | null): node is StaticBlock;
export declare function isTSParameterProperty(node: object | null | undefined, opts?: object | null): node is TSParameterProperty;
export declare function isTSDeclareFunction(node: object | null | undefined, opts?: object | null): node is TSDeclareFunction;
export declare function isTSDeclareMethod(node: object | null | undefined, opts?: object | null): node is TSDeclareMethod;
export declare function isTSQualifiedName(node: object | null | undefined, opts?: object | null): node is TSQualifiedName;
export declare function isTSCallSignatureDeclaration(node: object | null | undefined, opts?: object | null): node is TSCallSignatureDeclaration;
export declare function isTSConstructSignatureDeclaration(node: object | null | undefined, opts?: object | null): node is TSConstructSignatureDeclaration;
export declare function isTSPropertySignature(node: object | null | undefined, opts?: object | null): node is TSPropertySignature;
export declare function isTSMethodSignature(node: object | null | undefined, opts?: object | null): node is TSMethodSignature;
export declare function isTSIndexSignature(node: object | null | undefined, opts?: object | null): node is TSIndexSignature;
export declare function isTSAnyKeyword(node: object | null | undefined, opts?: object | null): node is TSAnyKeyword;
export declare function isTSBooleanKeyword(node: object | null | undefined, opts?: object | null): node is TSBooleanKeyword;
export declare function isTSBigIntKeyword(node: object | null | undefined, opts?: object | null): node is TSBigIntKeyword;
export declare function isTSIntrinsicKeyword(node: object | null | undefined, opts?: object | null): node is TSIntrinsicKeyword;
export declare function isTSNeverKeyword(node: object | null | undefined, opts?: object | null): node is TSNeverKeyword;
export declare function isTSNullKeyword(node: object | null | undefined, opts?: object | null): node is TSNullKeyword;
export declare function isTSNumberKeyword(node: object | null | undefined, opts?: object | null): node is TSNumberKeyword;
export declare function isTSObjectKeyword(node: object | null | undefined, opts?: object | null): node is TSObjectKeyword;
export declare function isTSStringKeyword(node: object | null | undefined, opts?: object | null): node is TSStringKeyword;
export declare function isTSSymbolKeyword(node: object | null | undefined, opts?: object | null): node is TSSymbolKeyword;
export declare function isTSUndefinedKeyword(node: object | null | undefined, opts?: object | null): node is TSUndefinedKeyword;
export declare function isTSUnknownKeyword(node: object | null | undefined, opts?: object | null): node is TSUnknownKeyword;
export declare function isTSVoidKeyword(node: object | null | undefined, opts?: object | null): node is TSVoidKeyword;
export declare function isTSThisType(node: object | null | undefined, opts?: object | null): node is TSThisType;
export declare function isTSFunctionType(node: object | null | undefined, opts?: object | null): node is TSFunctionType;
export declare function isTSConstructorType(node: object | null | undefined, opts?: object | null): node is TSConstructorType;
export declare function isTSTypeReference(node: object | null | undefined, opts?: object | null): node is TSTypeReference;
export declare function isTSTypePredicate(node: object | null | undefined, opts?: object | null): node is TSTypePredicate;
export declare function isTSTypeQuery(node: object | null | undefined, opts?: object | null): node is TSTypeQuery;
export declare function isTSTypeLiteral(node: object | null | undefined, opts?: object | null): node is TSTypeLiteral;
export declare function isTSArrayType(node: object | null | undefined, opts?: object | null): node is TSArrayType;
export declare function isTSTupleType(node: object | null | undefined, opts?: object | null): node is TSTupleType;
export declare function isTSOptionalType(node: object | null | undefined, opts?: object | null): node is TSOptionalType;
export declare function isTSRestType(node: object | null | undefined, opts?: object | null): node is TSRestType;
export declare function isTSNamedTupleMember(node: object | null | undefined, opts?: object | null): node is TSNamedTupleMember;
export declare function isTSUnionType(node: object | null | undefined, opts?: object | null): node is TSUnionType;
export declare function isTSIntersectionType(node: object | null | undefined, opts?: object | null): node is TSIntersectionType;
export declare function isTSConditionalType(node: object | null | undefined, opts?: object | null): node is TSConditionalType;
export declare function isTSInferType(node: object | null | undefined, opts?: object | null): node is TSInferType;
export declare function isTSParenthesizedType(node: object | null | undefined, opts?: object | null): node is TSParenthesizedType;
export declare function isTSTypeOperator(node: object | null | undefined, opts?: object | null): node is TSTypeOperator;
export declare function isTSIndexedAccessType(node: object | null | undefined, opts?: object | null): node is TSIndexedAccessType;
export declare function isTSMappedType(node: object | null | undefined, opts?: object | null): node is TSMappedType;
export declare function isTSLiteralType(node: object | null | undefined, opts?: object | null): node is TSLiteralType;
export declare function isTSExpressionWithTypeArguments(node: object | null | undefined, opts?: object | null): node is TSExpressionWithTypeArguments;
export declare function isTSInterfaceDeclaration(node: object | null | undefined, opts?: object | null): node is TSInterfaceDeclaration;
export declare function isTSInterfaceBody(node: object | null | undefined, opts?: object | null): node is TSInterfaceBody;
export declare function isTSTypeAliasDeclaration(node: object | null | undefined, opts?: object | null): node is TSTypeAliasDeclaration;
export declare function isTSAsExpression(node: object | null | undefined, opts?: object | null): node is TSAsExpression;
export declare function isTSTypeAssertion(node: object | null | undefined, opts?: object | null): node is TSTypeAssertion;
export declare function isTSEnumDeclaration(node: object | null | undefined, opts?: object | null): node is TSEnumDeclaration;
export declare function isTSEnumMember(node: object | null | undefined, opts?: object | null): node is TSEnumMember;
export declare function isTSModuleDeclaration(node: object | null | undefined, opts?: object | null): node is TSModuleDeclaration;
export declare function isTSModuleBlock(node: object | null | undefined, opts?: object | null): node is TSModuleBlock;
export declare function isTSImportType(node: object | null | undefined, opts?: object | null): node is TSImportType;
export declare function isTSImportEqualsDeclaration(node: object | null | undefined, opts?: object | null): node is TSImportEqualsDeclaration;
export declare function isTSExternalModuleReference(node: object | null | undefined, opts?: object | null): node is TSExternalModuleReference;
export declare function isTSNonNullExpression(node: object | null | undefined, opts?: object | null): node is TSNonNullExpression;
export declare function isTSExportAssignment(node: object | null | undefined, opts?: object | null): node is TSExportAssignment;
export declare function isTSNamespaceExportDeclaration(node: object | null | undefined, opts?: object | null): node is TSNamespaceExportDeclaration;
export declare function isTSTypeAnnotation(node: object | null | undefined, opts?: object | null): node is TSTypeAnnotation;
export declare function isTSTypeParameterInstantiation(node: object | null | undefined, opts?: object | null): node is TSTypeParameterInstantiation;
export declare function isTSTypeParameterDeclaration(node: object | null | undefined, opts?: object | null): node is TSTypeParameterDeclaration;
export declare function isTSTypeParameter(node: object | null | undefined, opts?: object | null): node is TSTypeParameter;
export declare function isExpression(node: object | null | undefined, opts?: object | null): node is Expression;
export declare function isBinary(node: object | null | undefined, opts?: object | null): node is Binary;
export declare function isScopable(node: object | null | undefined, opts?: object | null): node is Scopable;
export declare function isBlockParent(node: object | null | undefined, opts?: object | null): node is BlockParent;
export declare function isBlock(node: object | null | undefined, opts?: object | null): node is Block;
export declare function isStatement(node: object | null | undefined, opts?: object | null): node is Statement;
export declare function isTerminatorless(node: object | null | undefined, opts?: object | null): node is Terminatorless;
export declare function isCompletionStatement(node: object | null | undefined, opts?: object | null): node is CompletionStatement;
export declare function isConditional(node: object | null | undefined, opts?: object | null): node is Conditional;
export declare function isLoop(node: object | null | undefined, opts?: object | null): node is Loop;
export declare function isWhile(node: object | null | undefined, opts?: object | null): node is While;
export declare function isExpressionWrapper(node: object | null | undefined, opts?: object | null): node is ExpressionWrapper;
export declare function isFor(node: object | null | undefined, opts?: object | null): node is For;
export declare function isForXStatement(node: object | null | undefined, opts?: object | null): node is ForXStatement;
export declare function isFunction(node: object | null | undefined, opts?: object | null): node is Function;
export declare function isFunctionParent(node: object | null | undefined, opts?: object | null): node is FunctionParent;
export declare function isPureish(node: object | null | undefined, opts?: object | null): node is Pureish;
export declare function isDeclaration(node: object | null | undefined, opts?: object | null): node is Declaration;
export declare function isPatternLike(node: object | null | undefined, opts?: object | null): node is PatternLike;
export declare function isLVal(node: object | null | undefined, opts?: object | null): node is LVal;
export declare function isTSEntityName(node: object | null | undefined, opts?: object | null): node is TSEntityName;
export declare function isLiteral(node: object | null | undefined, opts?: object | null): node is Literal;
export declare function isUserWhitespacable(node: object | null | undefined, opts?: object | null): node is UserWhitespacable;
export declare function isMethod(node: object | null | undefined, opts?: object | null): node is Method;
export declare function isObjectMember(node: object | null | undefined, opts?: object | null): node is ObjectMember;
export declare function isProperty(node: object | null | undefined, opts?: object | null): node is Property;
export declare function isUnaryLike(node: object | null | undefined, opts?: object | null): node is UnaryLike;
export declare function isPattern(node: object | null | undefined, opts?: object | null): node is Pattern;
export declare function isClass(node: object | null | undefined, opts?: object | null): node is Class;
export declare function isModuleDeclaration(node: object | null | undefined, opts?: object | null): node is ModuleDeclaration;
export declare function isExportDeclaration(node: object | null | undefined, opts?: object | null): node is ExportDeclaration;
export declare function isModuleSpecifier(node: object | null | undefined, opts?: object | null): node is ModuleSpecifier;
export declare function isFlow(node: object | null | undefined, opts?: object | null): node is Flow;
export declare function isFlowType(node: object | null | undefined, opts?: object | null): node is FlowType;
export declare function isFlowBaseAnnotation(node: object | null | undefined, opts?: object | null): node is FlowBaseAnnotation;
export declare function isFlowDeclaration(node: object | null | undefined, opts?: object | null): node is FlowDeclaration;
export declare function isFlowPredicate(node: object | null | undefined, opts?: object | null): node is FlowPredicate;
export declare function isEnumBody(node: object | null | undefined, opts?: object | null): node is EnumBody;
export declare function isEnumMember(node: object | null | undefined, opts?: object | null): node is EnumMember;
export declare function isJSX(node: object | null | undefined, opts?: object | null): node is JSX;
export declare function isPrivate(node: object | null | undefined, opts?: object | null): node is Private;
export declare function isTSTypeElement(node: object | null | undefined, opts?: object | null): node is TSTypeElement;
export declare function isTSType(node: object | null | undefined, opts?: object | null): node is TSType;
export declare function isTSBaseType(node: object | null | undefined, opts?: object | null): node is TSBaseType;
export declare function isNumberLiteral(node: object | null | undefined, opts?: object | null): boolean;
export declare function isRegexLiteral(node: object | null | undefined, opts?: object | null): boolean;
export declare function isRestProperty(node: object | null | undefined, opts?: object | null): boolean;
export declare function isSpreadProperty(node: object | null | undefined, opts?: object | null): boolean;
export declare const react: {
	isReactComponent: (member: Node) => boolean;
	isCompatTag: typeof isCompatTag;
	buildChildren: typeof buildChildren;
};

export {};
