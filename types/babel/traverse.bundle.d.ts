// Generated by dts-bundle-generator v5.6.0

import * as t from './types';

export interface BaseComment {
	value: string;
	start: number;
	end: number;
	loc: SourceLocation;
	type: "CommentBlock" | "CommentLine";
}
export interface CommentBlock extends BaseComment {
	type: "CommentBlock";
}
export interface CommentLine extends BaseComment {
	type: "CommentLine";
}
export declare type Comment = CommentBlock | CommentLine;
export interface SourceLocation {
	start: {
		line: number;
		column: number;
	};
	end: {
		line: number;
		column: number;
	};
}
export interface BaseNode {
	leadingComments: ReadonlyArray<Comment> | null;
	innerComments: ReadonlyArray<Comment> | null;
	trailingComments: ReadonlyArray<Comment> | null;
	start: number | null;
	end: number | null;
	loc: SourceLocation | null;
	type: Node["type"];
	extra?: Record<string, unknown>;
}
export declare type Node = AnyTypeAnnotation | ArgumentPlaceholder | ArrayExpression | ArrayPattern | ArrayTypeAnnotation | ArrowFunctionExpression | AssignmentExpression | AssignmentPattern | AwaitExpression | BigIntLiteral | Binary | BinaryExpression | BindExpression | Block | BlockParent | BlockStatement | BooleanLiteral | BooleanLiteralTypeAnnotation | BooleanTypeAnnotation | BreakStatement | CallExpression | CatchClause | Class | ClassBody | ClassDeclaration | ClassExpression | ClassImplements | ClassMethod | ClassPrivateMethod | ClassPrivateProperty | ClassProperty | CompletionStatement | Conditional | ConditionalExpression | ContinueStatement | DebuggerStatement | DecimalLiteral | Declaration | DeclareClass | DeclareExportAllDeclaration | DeclareExportDeclaration | DeclareFunction | DeclareInterface | DeclareModule | DeclareModuleExports | DeclareOpaqueType | DeclareTypeAlias | DeclareVariable | DeclaredPredicate | Decorator | Directive | DirectiveLiteral | DoExpression | DoWhileStatement | EmptyStatement | EmptyTypeAnnotation | EnumBody | EnumBooleanBody | EnumBooleanMember | EnumDeclaration | EnumDefaultedMember | EnumMember | EnumNumberBody | EnumNumberMember | EnumStringBody | EnumStringMember | EnumSymbolBody | ExistsTypeAnnotation | ExportAllDeclaration | ExportDeclaration | ExportDefaultDeclaration | ExportDefaultSpecifier | ExportNamedDeclaration | ExportNamespaceSpecifier | ExportSpecifier | Expression | ExpressionStatement | ExpressionWrapper | File | Flow | FlowBaseAnnotation | FlowDeclaration | FlowPredicate | FlowType | For | ForInStatement | ForOfStatement | ForStatement | ForXStatement | Function | FunctionDeclaration | FunctionExpression | FunctionParent | FunctionTypeAnnotation | FunctionTypeParam | GenericTypeAnnotation | Identifier | IfStatement | Immutable | Import | ImportAttribute | ImportDeclaration | ImportDefaultSpecifier | ImportNamespaceSpecifier | ImportSpecifier | InferredPredicate | InterfaceDeclaration | InterfaceExtends | InterfaceTypeAnnotation | InterpreterDirective | IntersectionTypeAnnotation | JSX | JSXAttribute | JSXClosingElement | JSXClosingFragment | JSXElement | JSXEmptyExpression | JSXExpressionContainer | JSXFragment | JSXIdentifier | JSXMemberExpression | JSXNamespacedName | JSXOpeningElement | JSXOpeningFragment | JSXSpreadAttribute | JSXSpreadChild | JSXText | LVal | LabeledStatement | Literal | LogicalExpression | Loop | MemberExpression | MetaProperty | Method | MixedTypeAnnotation | ModuleDeclaration | ModuleSpecifier | NewExpression | Noop | NullLiteral | NullLiteralTypeAnnotation | NullableTypeAnnotation | NumberLiteral | NumberLiteralTypeAnnotation | NumberTypeAnnotation | NumericLiteral | ObjectExpression | ObjectMember | ObjectMethod | ObjectPattern | ObjectProperty | ObjectTypeAnnotation | ObjectTypeCallProperty | ObjectTypeIndexer | ObjectTypeInternalSlot | ObjectTypeProperty | ObjectTypeSpreadProperty | OpaqueType | OptionalCallExpression | OptionalMemberExpression | ParenthesizedExpression | Pattern | PatternLike | PipelineBareFunction | PipelinePrimaryTopicReference | PipelineTopicExpression | Placeholder | Private | PrivateName | Program | Property | Pureish | QualifiedTypeIdentifier | RecordExpression | RegExpLiteral | RegexLiteral | RestElement | RestProperty | ReturnStatement | Scopable | SequenceExpression | SpreadElement | SpreadProperty | Statement | StaticBlock | StringLiteral | StringLiteralTypeAnnotation | StringTypeAnnotation | Super | SwitchCase | SwitchStatement | SymbolTypeAnnotation | TSAnyKeyword | TSArrayType | TSAsExpression | TSBaseType | TSBigIntKeyword | TSBooleanKeyword | TSCallSignatureDeclaration | TSConditionalType | TSConstructSignatureDeclaration | TSConstructorType | TSDeclareFunction | TSDeclareMethod | TSEntityName | TSEnumDeclaration | TSEnumMember | TSExportAssignment | TSExpressionWithTypeArguments | TSExternalModuleReference | TSFunctionType | TSImportEqualsDeclaration | TSImportType | TSIndexSignature | TSIndexedAccessType | TSInferType | TSInterfaceBody | TSInterfaceDeclaration | TSIntersectionType | TSIntrinsicKeyword | TSLiteralType | TSMappedType | TSMethodSignature | TSModuleBlock | TSModuleDeclaration | TSNamedTupleMember | TSNamespaceExportDeclaration | TSNeverKeyword | TSNonNullExpression | TSNullKeyword | TSNumberKeyword | TSObjectKeyword | TSOptionalType | TSParameterProperty | TSParenthesizedType | TSPropertySignature | TSQualifiedName | TSRestType | TSStringKeyword | TSSymbolKeyword | TSThisType | TSTupleType | TSType | TSTypeAliasDeclaration | TSTypeAnnotation | TSTypeAssertion | TSTypeElement | TSTypeLiteral | TSTypeOperator | TSTypeParameter | TSTypeParameterDeclaration | TSTypeParameterInstantiation | TSTypePredicate | TSTypeQuery | TSTypeReference | TSUndefinedKeyword | TSUnionType | TSUnknownKeyword | TSVoidKeyword | TaggedTemplateExpression | TemplateElement | TemplateLiteral | Terminatorless | ThisExpression | ThisTypeAnnotation | ThrowStatement | TryStatement | TupleExpression | TupleTypeAnnotation | TypeAlias | TypeAnnotation | TypeCastExpression | TypeParameter | TypeParameterDeclaration | TypeParameterInstantiation | TypeofTypeAnnotation | UnaryExpression | UnaryLike | UnionTypeAnnotation | UpdateExpression | UserWhitespacable | V8IntrinsicIdentifier | VariableDeclaration | VariableDeclarator | Variance | VoidTypeAnnotation | While | WhileStatement | WithStatement | YieldExpression;
export interface ArrayExpression extends BaseNode {
	type: "ArrayExpression";
	elements: Array<null | Expression | SpreadElement>;
}
export interface AssignmentExpression extends BaseNode {
	type: "AssignmentExpression";
	operator: string;
	left: LVal;
	right: Expression;
}
export interface BinaryExpression extends BaseNode {
	type: "BinaryExpression";
	operator: "+" | "-" | "/" | "%" | "*" | "**" | "&" | "|" | ">>" | ">>>" | "<<" | "^" | "==" | "===" | "!=" | "!==" | "in" | "instanceof" | ">" | "<" | ">=" | "<=";
	left: Expression | PrivateName;
	right: Expression;
}
export interface InterpreterDirective extends BaseNode {
	type: "InterpreterDirective";
	value: string;
}
export interface Directive extends BaseNode {
	type: "Directive";
	value: DirectiveLiteral;
}
export interface DirectiveLiteral extends BaseNode {
	type: "DirectiveLiteral";
	value: string;
}
export interface BlockStatement extends BaseNode {
	type: "BlockStatement";
	body: Array<Statement>;
	directives: Array<Directive>;
}
export interface BreakStatement extends BaseNode {
	type: "BreakStatement";
	label?: Identifier | null;
}
export interface CallExpression extends BaseNode {
	type: "CallExpression";
	callee: Expression | V8IntrinsicIdentifier;
	arguments: Array<Expression | SpreadElement | JSXNamespacedName | ArgumentPlaceholder>;
	optional?: true | false | null;
	typeArguments?: TypeParameterInstantiation | null;
	typeParameters?: TSTypeParameterInstantiation | null;
}
export interface CatchClause extends BaseNode {
	type: "CatchClause";
	param?: Identifier | ArrayPattern | ObjectPattern | null;
	body: BlockStatement;
}
export interface ConditionalExpression extends BaseNode {
	type: "ConditionalExpression";
	test: Expression;
	consequent: Expression;
	alternate: Expression;
}
export interface ContinueStatement extends BaseNode {
	type: "ContinueStatement";
	label?: Identifier | null;
}
export interface DebuggerStatement extends BaseNode {
	type: "DebuggerStatement";
}
export interface DoWhileStatement extends BaseNode {
	type: "DoWhileStatement";
	test: Expression;
	body: Statement;
}
export interface EmptyStatement extends BaseNode {
	type: "EmptyStatement";
}
export interface ExpressionStatement extends BaseNode {
	type: "ExpressionStatement";
	expression: Expression;
}
export interface File extends BaseNode {
	type: "File";
	program: Program;
	comments?: Array<CommentBlock | CommentLine> | null;
	tokens?: Array<any> | null;
}
export interface ForInStatement extends BaseNode {
	type: "ForInStatement";
	left: VariableDeclaration | LVal;
	right: Expression;
	body: Statement;
}
export interface ForStatement extends BaseNode {
	type: "ForStatement";
	init?: VariableDeclaration | Expression | null;
	test?: Expression | null;
	update?: Expression | null;
	body: Statement;
}
export interface FunctionDeclaration extends BaseNode {
	type: "FunctionDeclaration";
	id?: Identifier | null;
	params: Array<Identifier | Pattern | RestElement | TSParameterProperty>;
	body: BlockStatement;
	generator?: boolean;
	async?: boolean;
	declare?: boolean | null;
	returnType?: TypeAnnotation | TSTypeAnnotation | Noop | null;
	typeParameters?: TypeParameterDeclaration | TSTypeParameterDeclaration | Noop | null;
}
export interface FunctionExpression extends BaseNode {
	type: "FunctionExpression";
	id?: Identifier | null;
	params: Array<Identifier | Pattern | RestElement | TSParameterProperty>;
	body: BlockStatement;
	generator?: boolean;
	async?: boolean;
	returnType?: TypeAnnotation | TSTypeAnnotation | Noop | null;
	typeParameters?: TypeParameterDeclaration | TSTypeParameterDeclaration | Noop | null;
}
export interface Identifier extends BaseNode {
	type: "Identifier";
	name: string;
	decorators?: Array<Decorator> | null;
	optional?: boolean | null;
	typeAnnotation?: TypeAnnotation | TSTypeAnnotation | Noop | null;
}
export interface IfStatement extends BaseNode {
	type: "IfStatement";
	test: Expression;
	consequent: Statement;
	alternate?: Statement | null;
}
export interface LabeledStatement extends BaseNode {
	type: "LabeledStatement";
	label: Identifier;
	body: Statement;
}
export interface StringLiteral extends BaseNode {
	type: "StringLiteral";
	value: string;
}
export interface NumericLiteral extends BaseNode {
	type: "NumericLiteral";
	value: number;
}
/**
 * @deprecated Use `NumericLiteral`
 */
export interface NumberLiteral extends BaseNode {
	type: "NumberLiteral";
	value: number;
}
export interface NullLiteral extends BaseNode {
	type: "NullLiteral";
}
export interface BooleanLiteral extends BaseNode {
	type: "BooleanLiteral";
	value: boolean;
}
export interface RegExpLiteral extends BaseNode {
	type: "RegExpLiteral";
	pattern: string;
	flags: string;
}
/**
 * @deprecated Use `RegExpLiteral`
 */
export interface RegexLiteral extends BaseNode {
	type: "RegexLiteral";
	pattern: string;
	flags: string;
}
export interface LogicalExpression extends BaseNode {
	type: "LogicalExpression";
	operator: "||" | "&&" | "??";
	left: Expression;
	right: Expression;
}
export interface MemberExpression extends BaseNode {
	type: "MemberExpression";
	object: Expression;
	property: Expression | Identifier | PrivateName;
	computed: boolean;
	optional?: true | false | null;
}
export interface NewExpression extends BaseNode {
	type: "NewExpression";
	callee: Expression | V8IntrinsicIdentifier;
	arguments: Array<Expression | SpreadElement | JSXNamespacedName | ArgumentPlaceholder>;
	optional?: true | false | null;
	typeArguments?: TypeParameterInstantiation | null;
	typeParameters?: TSTypeParameterInstantiation | null;
}
export interface Program extends BaseNode {
	type: "Program";
	body: Array<Statement>;
	directives: Array<Directive>;
	sourceType: "script" | "module";
	interpreter?: InterpreterDirective | null;
	sourceFile: string;
}
export interface ObjectExpression extends BaseNode {
	type: "ObjectExpression";
	properties: Array<ObjectMethod | ObjectProperty | SpreadElement>;
}
export interface ObjectMethod extends BaseNode {
	type: "ObjectMethod";
	kind: "method" | "get" | "set";
	key: Expression | Identifier | StringLiteral | NumericLiteral;
	params: Array<Identifier | Pattern | RestElement | TSParameterProperty>;
	body: BlockStatement;
	computed: boolean;
	generator?: boolean;
	async?: boolean;
	decorators?: Array<Decorator> | null;
	returnType?: TypeAnnotation | TSTypeAnnotation | Noop | null;
	typeParameters?: TypeParameterDeclaration | TSTypeParameterDeclaration | Noop | null;
}
export interface ObjectProperty extends BaseNode {
	type: "ObjectProperty";
	key: Expression | Identifier | StringLiteral | NumericLiteral;
	value: Expression | PatternLike;
	computed: boolean;
	shorthand: boolean;
	decorators?: Array<Decorator> | null;
}
export interface RestElement extends BaseNode {
	type: "RestElement";
	argument: LVal;
	decorators?: Array<Decorator> | null;
	typeAnnotation?: TypeAnnotation | TSTypeAnnotation | Noop | null;
}
/**
 * @deprecated Use `RestElement`
 */
export interface RestProperty extends BaseNode {
	type: "RestProperty";
	argument: LVal;
	decorators?: Array<Decorator> | null;
	typeAnnotation?: TypeAnnotation | TSTypeAnnotation | Noop | null;
}
export interface ReturnStatement extends BaseNode {
	type: "ReturnStatement";
	argument?: Expression | null;
}
export interface SequenceExpression extends BaseNode {
	type: "SequenceExpression";
	expressions: Array<Expression>;
}
export interface ParenthesizedExpression extends BaseNode {
	type: "ParenthesizedExpression";
	expression: Expression;
}
export interface SwitchCase extends BaseNode {
	type: "SwitchCase";
	test?: Expression | null;
	consequent: Array<Statement>;
}
export interface SwitchStatement extends BaseNode {
	type: "SwitchStatement";
	discriminant: Expression;
	cases: Array<SwitchCase>;
}
export interface ThisExpression extends BaseNode {
	type: "ThisExpression";
}
export interface ThrowStatement extends BaseNode {
	type: "ThrowStatement";
	argument: Expression;
}
export interface TryStatement extends BaseNode {
	type: "TryStatement";
	block: BlockStatement;
	handler?: CatchClause | null;
	finalizer?: BlockStatement | null;
}
export interface UnaryExpression extends BaseNode {
	type: "UnaryExpression";
	operator: "void" | "throw" | "delete" | "!" | "+" | "-" | "~" | "typeof";
	argument: Expression;
	prefix: boolean;
}
export interface UpdateExpression extends BaseNode {
	type: "UpdateExpression";
	operator: "++" | "--";
	argument: Expression;
	prefix: boolean;
}
export interface VariableDeclaration extends BaseNode {
	type: "VariableDeclaration";
	kind: "var" | "let" | "const";
	declarations: Array<VariableDeclarator>;
	declare?: boolean | null;
}
export interface VariableDeclarator extends BaseNode {
	type: "VariableDeclarator";
	id: LVal;
	init?: Expression | null;
	definite?: boolean | null;
}
export interface WhileStatement extends BaseNode {
	type: "WhileStatement";
	test: Expression;
	body: Statement;
}
export interface WithStatement extends BaseNode {
	type: "WithStatement";
	object: Expression;
	body: Statement;
}
export interface AssignmentPattern extends BaseNode {
	type: "AssignmentPattern";
	left: Identifier | ObjectPattern | ArrayPattern | MemberExpression;
	right: Expression;
	decorators?: Array<Decorator> | null;
	typeAnnotation?: TypeAnnotation | TSTypeAnnotation | Noop | null;
}
export interface ArrayPattern extends BaseNode {
	type: "ArrayPattern";
	elements: Array<null | PatternLike>;
	decorators?: Array<Decorator> | null;
	typeAnnotation?: TypeAnnotation | TSTypeAnnotation | Noop | null;
}
export interface ArrowFunctionExpression extends BaseNode {
	type: "ArrowFunctionExpression";
	params: Array<Identifier | Pattern | RestElement | TSParameterProperty>;
	body: BlockStatement | Expression;
	async?: boolean;
	expression: boolean;
	generator?: boolean;
	returnType?: TypeAnnotation | TSTypeAnnotation | Noop | null;
	typeParameters?: TypeParameterDeclaration | TSTypeParameterDeclaration | Noop | null;
}
export interface ClassBody extends BaseNode {
	type: "ClassBody";
	body: Array<ClassMethod | ClassPrivateMethod | ClassProperty | ClassPrivateProperty | TSDeclareMethod | TSIndexSignature>;
}
export interface ClassExpression extends BaseNode {
	type: "ClassExpression";
	id?: Identifier | null;
	superClass?: Expression | null;
	body: ClassBody;
	decorators?: Array<Decorator> | null;
	implements?: Array<TSExpressionWithTypeArguments | ClassImplements> | null;
	mixins?: InterfaceExtends | null;
	superTypeParameters?: TypeParameterInstantiation | TSTypeParameterInstantiation | null;
	typeParameters?: TypeParameterDeclaration | TSTypeParameterDeclaration | Noop | null;
}
export interface ClassDeclaration extends BaseNode {
	type: "ClassDeclaration";
	id: Identifier;
	superClass?: Expression | null;
	body: ClassBody;
	decorators?: Array<Decorator> | null;
	abstract?: boolean | null;
	declare?: boolean | null;
	implements?: Array<TSExpressionWithTypeArguments | ClassImplements> | null;
	mixins?: InterfaceExtends | null;
	superTypeParameters?: TypeParameterInstantiation | TSTypeParameterInstantiation | null;
	typeParameters?: TypeParameterDeclaration | TSTypeParameterDeclaration | Noop | null;
}
export interface ExportAllDeclaration extends BaseNode {
	type: "ExportAllDeclaration";
	source: StringLiteral;
	assertions?: ImportAttribute | null;
	exportKind?: "type" | "value" | null;
}
export interface ExportDefaultDeclaration extends BaseNode {
	type: "ExportDefaultDeclaration";
	declaration: FunctionDeclaration | TSDeclareFunction | ClassDeclaration | Expression;
}
export interface ExportNamedDeclaration extends BaseNode {
	type: "ExportNamedDeclaration";
	declaration?: Declaration | null;
	specifiers: Array<ExportSpecifier | ExportDefaultSpecifier | ExportNamespaceSpecifier>;
	source?: StringLiteral | null;
	assertions?: ImportAttribute | null;
	exportKind?: "type" | "value" | null;
}
export interface ExportSpecifier extends BaseNode {
	type: "ExportSpecifier";
	local: Identifier;
	exported: Identifier | StringLiteral;
}
export interface ForOfStatement extends BaseNode {
	type: "ForOfStatement";
	left: VariableDeclaration | LVal;
	right: Expression;
	body: Statement;
	await: boolean;
}
export interface ImportDeclaration extends BaseNode {
	type: "ImportDeclaration";
	specifiers: Array<ImportSpecifier | ImportDefaultSpecifier | ImportNamespaceSpecifier>;
	source: StringLiteral;
	assertions?: ImportAttribute | null;
	importKind?: "type" | "typeof" | "value" | null;
}
export interface ImportDefaultSpecifier extends BaseNode {
	type: "ImportDefaultSpecifier";
	local: Identifier;
}
export interface ImportNamespaceSpecifier extends BaseNode {
	type: "ImportNamespaceSpecifier";
	local: Identifier;
}
export interface ImportSpecifier extends BaseNode {
	type: "ImportSpecifier";
	local: Identifier;
	imported: Identifier | StringLiteral;
	importKind?: "type" | "typeof" | null;
}
export interface MetaProperty extends BaseNode {
	type: "MetaProperty";
	meta: Identifier;
	property: Identifier;
}
export interface ClassMethod extends BaseNode {
	type: "ClassMethod";
	kind?: "get" | "set" | "method" | "constructor";
	key: Identifier | StringLiteral | NumericLiteral | Expression;
	params: Array<Identifier | Pattern | RestElement | TSParameterProperty>;
	body: BlockStatement;
	computed?: boolean;
	static?: boolean;
	generator?: boolean;
	async?: boolean;
	abstract?: boolean | null;
	access?: "public" | "private" | "protected" | null;
	accessibility?: "public" | "private" | "protected" | null;
	decorators?: Array<Decorator> | null;
	optional?: boolean | null;
	returnType?: TypeAnnotation | TSTypeAnnotation | Noop | null;
	typeParameters?: TypeParameterDeclaration | TSTypeParameterDeclaration | Noop | null;
}
export interface ObjectPattern extends BaseNode {
	type: "ObjectPattern";
	properties: Array<RestElement | ObjectProperty>;
	decorators?: Array<Decorator> | null;
	typeAnnotation?: TypeAnnotation | TSTypeAnnotation | Noop | null;
}
export interface SpreadElement extends BaseNode {
	type: "SpreadElement";
	argument: Expression;
}
/**
 * @deprecated Use `SpreadElement`
 */
export interface SpreadProperty extends BaseNode {
	type: "SpreadProperty";
	argument: Expression;
}
export interface Super extends BaseNode {
	type: "Super";
}
export interface TaggedTemplateExpression extends BaseNode {
	type: "TaggedTemplateExpression";
	tag: Expression;
	quasi: TemplateLiteral;
	typeParameters?: TypeParameterInstantiation | TSTypeParameterInstantiation | null;
}
export interface TemplateElement extends BaseNode {
	type: "TemplateElement";
	value: {
		raw: string;
		cooked?: string;
	};
	tail: boolean;
}
export interface TemplateLiteral extends BaseNode {
	type: "TemplateLiteral";
	quasis: Array<TemplateElement>;
	expressions: Array<Expression | TSType>;
}
export interface YieldExpression extends BaseNode {
	type: "YieldExpression";
	argument?: Expression | null;
	delegate: boolean;
}
export interface AwaitExpression extends BaseNode {
	type: "AwaitExpression";
	argument: Expression;
}
export interface Import extends BaseNode {
	type: "Import";
}
export interface BigIntLiteral extends BaseNode {
	type: "BigIntLiteral";
	value: string;
}
export interface ExportNamespaceSpecifier extends BaseNode {
	type: "ExportNamespaceSpecifier";
	exported: Identifier;
}
export interface OptionalMemberExpression extends BaseNode {
	type: "OptionalMemberExpression";
	object: Expression;
	property: Expression | Identifier;
	computed: boolean;
	optional: boolean;
}
export interface OptionalCallExpression extends BaseNode {
	type: "OptionalCallExpression";
	callee: Expression;
	arguments: Array<Expression | SpreadElement | JSXNamespacedName | ArgumentPlaceholder>;
	optional: boolean;
	typeArguments?: TypeParameterInstantiation | null;
	typeParameters?: TSTypeParameterInstantiation | null;
}
export interface AnyTypeAnnotation extends BaseNode {
	type: "AnyTypeAnnotation";
}
export interface ArrayTypeAnnotation extends BaseNode {
	type: "ArrayTypeAnnotation";
	elementType: FlowType;
}
export interface BooleanTypeAnnotation extends BaseNode {
	type: "BooleanTypeAnnotation";
}
export interface BooleanLiteralTypeAnnotation extends BaseNode {
	type: "BooleanLiteralTypeAnnotation";
	value: boolean;
}
export interface NullLiteralTypeAnnotation extends BaseNode {
	type: "NullLiteralTypeAnnotation";
}
export interface ClassImplements extends BaseNode {
	type: "ClassImplements";
	id: Identifier;
	typeParameters?: TypeParameterInstantiation | null;
}
export interface DeclareClass extends BaseNode {
	type: "DeclareClass";
	id: Identifier;
	typeParameters?: TypeParameterDeclaration | null;
	extends?: Array<InterfaceExtends> | null;
	body: ObjectTypeAnnotation;
	implements?: Array<ClassImplements> | null;
	mixins?: Array<InterfaceExtends> | null;
}
export interface DeclareFunction extends BaseNode {
	type: "DeclareFunction";
	id: Identifier;
	predicate?: DeclaredPredicate | null;
}
export interface DeclareInterface extends BaseNode {
	type: "DeclareInterface";
	id: Identifier;
	typeParameters?: TypeParameterDeclaration | null;
	extends?: Array<InterfaceExtends> | null;
	body: ObjectTypeAnnotation;
	implements?: Array<ClassImplements> | null;
	mixins?: Array<InterfaceExtends> | null;
}
export interface DeclareModule extends BaseNode {
	type: "DeclareModule";
	id: Identifier | StringLiteral;
	body: BlockStatement;
	kind?: "CommonJS" | "ES" | null;
}
export interface DeclareModuleExports extends BaseNode {
	type: "DeclareModuleExports";
	typeAnnotation: TypeAnnotation;
}
export interface DeclareTypeAlias extends BaseNode {
	type: "DeclareTypeAlias";
	id: Identifier;
	typeParameters?: TypeParameterDeclaration | null;
	right: FlowType;
}
export interface DeclareOpaqueType extends BaseNode {
	type: "DeclareOpaqueType";
	id: Identifier;
	typeParameters?: TypeParameterDeclaration | null;
	supertype?: FlowType | null;
}
export interface DeclareVariable extends BaseNode {
	type: "DeclareVariable";
	id: Identifier;
}
export interface DeclareExportDeclaration extends BaseNode {
	type: "DeclareExportDeclaration";
	declaration?: Flow | null;
	specifiers?: Array<ExportSpecifier | ExportNamespaceSpecifier> | null;
	source?: StringLiteral | null;
	default?: boolean | null;
}
export interface DeclareExportAllDeclaration extends BaseNode {
	type: "DeclareExportAllDeclaration";
	source: StringLiteral;
	exportKind?: "type" | "value" | null;
}
export interface DeclaredPredicate extends BaseNode {
	type: "DeclaredPredicate";
	value: Flow;
}
export interface ExistsTypeAnnotation extends BaseNode {
	type: "ExistsTypeAnnotation";
}
export interface FunctionTypeAnnotation extends BaseNode {
	type: "FunctionTypeAnnotation";
	typeParameters?: TypeParameterDeclaration | null;
	params: Array<FunctionTypeParam>;
	rest?: FunctionTypeParam | null;
	returnType: FlowType;
}
export interface FunctionTypeParam extends BaseNode {
	type: "FunctionTypeParam";
	name?: Identifier | null;
	typeAnnotation: FlowType;
	optional?: boolean | null;
}
export interface GenericTypeAnnotation extends BaseNode {
	type: "GenericTypeAnnotation";
	id: Identifier | QualifiedTypeIdentifier;
	typeParameters?: TypeParameterInstantiation | null;
}
export interface InferredPredicate extends BaseNode {
	type: "InferredPredicate";
}
export interface InterfaceExtends extends BaseNode {
	type: "InterfaceExtends";
	id: Identifier | QualifiedTypeIdentifier;
	typeParameters?: TypeParameterInstantiation | null;
}
export interface InterfaceDeclaration extends BaseNode {
	type: "InterfaceDeclaration";
	id: Identifier;
	typeParameters?: TypeParameterDeclaration | null;
	extends?: Array<InterfaceExtends> | null;
	body: ObjectTypeAnnotation;
	implements?: Array<ClassImplements> | null;
	mixins?: Array<InterfaceExtends> | null;
}
export interface InterfaceTypeAnnotation extends BaseNode {
	type: "InterfaceTypeAnnotation";
	extends?: Array<InterfaceExtends> | null;
	body: ObjectTypeAnnotation;
}
export interface IntersectionTypeAnnotation extends BaseNode {
	type: "IntersectionTypeAnnotation";
	types: Array<FlowType>;
}
export interface MixedTypeAnnotation extends BaseNode {
	type: "MixedTypeAnnotation";
}
export interface EmptyTypeAnnotation extends BaseNode {
	type: "EmptyTypeAnnotation";
}
export interface NullableTypeAnnotation extends BaseNode {
	type: "NullableTypeAnnotation";
	typeAnnotation: FlowType;
}
export interface NumberLiteralTypeAnnotation extends BaseNode {
	type: "NumberLiteralTypeAnnotation";
	value: number;
}
export interface NumberTypeAnnotation extends BaseNode {
	type: "NumberTypeAnnotation";
}
export interface ObjectTypeAnnotation extends BaseNode {
	type: "ObjectTypeAnnotation";
	properties: Array<ObjectTypeProperty | ObjectTypeSpreadProperty>;
	indexers?: Array<ObjectTypeIndexer> | null;
	callProperties?: Array<ObjectTypeCallProperty> | null;
	internalSlots?: Array<ObjectTypeInternalSlot> | null;
	exact: boolean;
	inexact?: boolean | null;
}
export interface ObjectTypeInternalSlot extends BaseNode {
	type: "ObjectTypeInternalSlot";
	id: Identifier;
	value: FlowType;
	optional: boolean;
	static: boolean;
	method: boolean;
}
export interface ObjectTypeCallProperty extends BaseNode {
	type: "ObjectTypeCallProperty";
	value: FlowType;
	static: boolean;
}
export interface ObjectTypeIndexer extends BaseNode {
	type: "ObjectTypeIndexer";
	id?: Identifier | null;
	key: FlowType;
	value: FlowType;
	variance?: Variance | null;
	static: boolean;
}
export interface ObjectTypeProperty extends BaseNode {
	type: "ObjectTypeProperty";
	key: Identifier | StringLiteral;
	value: FlowType;
	variance?: Variance | null;
	kind: "init" | "get" | "set";
	method: boolean;
	optional: boolean;
	proto: boolean;
	static: boolean;
}
export interface ObjectTypeSpreadProperty extends BaseNode {
	type: "ObjectTypeSpreadProperty";
	argument: FlowType;
}
export interface OpaqueType extends BaseNode {
	type: "OpaqueType";
	id: Identifier;
	typeParameters?: TypeParameterDeclaration | null;
	supertype?: FlowType | null;
	impltype: FlowType;
}
export interface QualifiedTypeIdentifier extends BaseNode {
	type: "QualifiedTypeIdentifier";
	id: Identifier;
	qualification: Identifier | QualifiedTypeIdentifier;
}
export interface StringLiteralTypeAnnotation extends BaseNode {
	type: "StringLiteralTypeAnnotation";
	value: string;
}
export interface StringTypeAnnotation extends BaseNode {
	type: "StringTypeAnnotation";
}
export interface SymbolTypeAnnotation extends BaseNode {
	type: "SymbolTypeAnnotation";
}
export interface ThisTypeAnnotation extends BaseNode {
	type: "ThisTypeAnnotation";
}
export interface TupleTypeAnnotation extends BaseNode {
	type: "TupleTypeAnnotation";
	types: Array<FlowType>;
}
export interface TypeofTypeAnnotation extends BaseNode {
	type: "TypeofTypeAnnotation";
	argument: FlowType;
}
export interface TypeAlias extends BaseNode {
	type: "TypeAlias";
	id: Identifier;
	typeParameters?: TypeParameterDeclaration | null;
	right: FlowType;
}
export interface TypeAnnotation extends BaseNode {
	type: "TypeAnnotation";
	typeAnnotation: FlowType;
}
export interface TypeCastExpression extends BaseNode {
	type: "TypeCastExpression";
	expression: Expression;
	typeAnnotation: TypeAnnotation;
}
export interface TypeParameter extends BaseNode {
	type: "TypeParameter";
	bound?: TypeAnnotation | null;
	default?: FlowType | null;
	variance?: Variance | null;
	name: string;
}
export interface TypeParameterDeclaration extends BaseNode {
	type: "TypeParameterDeclaration";
	params: Array<TypeParameter>;
}
export interface TypeParameterInstantiation extends BaseNode {
	type: "TypeParameterInstantiation";
	params: Array<FlowType>;
}
export interface UnionTypeAnnotation extends BaseNode {
	type: "UnionTypeAnnotation";
	types: Array<FlowType>;
}
export interface Variance extends BaseNode {
	type: "Variance";
	kind: "minus" | "plus";
}
export interface VoidTypeAnnotation extends BaseNode {
	type: "VoidTypeAnnotation";
}
export interface EnumDeclaration extends BaseNode {
	type: "EnumDeclaration";
	id: Identifier;
	body: EnumBooleanBody | EnumNumberBody | EnumStringBody | EnumSymbolBody;
}
export interface EnumBooleanBody extends BaseNode {
	type: "EnumBooleanBody";
	members: Array<EnumBooleanMember>;
	explicitType: boolean;
}
export interface EnumNumberBody extends BaseNode {
	type: "EnumNumberBody";
	members: Array<EnumNumberMember>;
	explicitType: boolean;
}
export interface EnumStringBody extends BaseNode {
	type: "EnumStringBody";
	members: Array<EnumStringMember | EnumDefaultedMember>;
	explicitType: boolean;
}
export interface EnumSymbolBody extends BaseNode {
	type: "EnumSymbolBody";
	members: Array<EnumDefaultedMember>;
}
export interface EnumBooleanMember extends BaseNode {
	type: "EnumBooleanMember";
	id: Identifier;
	init: BooleanLiteral;
}
export interface EnumNumberMember extends BaseNode {
	type: "EnumNumberMember";
	id: Identifier;
	init: NumericLiteral;
}
export interface EnumStringMember extends BaseNode {
	type: "EnumStringMember";
	id: Identifier;
	init: StringLiteral;
}
export interface EnumDefaultedMember extends BaseNode {
	type: "EnumDefaultedMember";
	id: Identifier;
}
export interface JSXAttribute extends BaseNode {
	type: "JSXAttribute";
	name: JSXIdentifier | JSXNamespacedName;
	value?: JSXElement | JSXFragment | StringLiteral | JSXExpressionContainer | null;
}
export interface JSXClosingElement extends BaseNode {
	type: "JSXClosingElement";
	name: JSXIdentifier | JSXMemberExpression | JSXNamespacedName;
}
export interface JSXElement extends BaseNode {
	type: "JSXElement";
	openingElement: JSXOpeningElement;
	closingElement?: JSXClosingElement | null;
	children: Array<JSXText | JSXExpressionContainer | JSXSpreadChild | JSXElement | JSXFragment>;
	selfClosing?: boolean | null;
}
export interface JSXEmptyExpression extends BaseNode {
	type: "JSXEmptyExpression";
}
export interface JSXExpressionContainer extends BaseNode {
	type: "JSXExpressionContainer";
	expression: Expression | JSXEmptyExpression;
}
export interface JSXSpreadChild extends BaseNode {
	type: "JSXSpreadChild";
	expression: Expression;
}
export interface JSXIdentifier extends BaseNode {
	type: "JSXIdentifier";
	name: string;
}
export interface JSXMemberExpression extends BaseNode {
	type: "JSXMemberExpression";
	object: JSXMemberExpression | JSXIdentifier;
	property: JSXIdentifier;
}
export interface JSXNamespacedName extends BaseNode {
	type: "JSXNamespacedName";
	namespace: JSXIdentifier;
	name: JSXIdentifier;
}
export interface JSXOpeningElement extends BaseNode {
	type: "JSXOpeningElement";
	name: JSXIdentifier | JSXMemberExpression | JSXNamespacedName;
	attributes: Array<JSXAttribute | JSXSpreadAttribute>;
	selfClosing: boolean;
	typeParameters?: TypeParameterInstantiation | TSTypeParameterInstantiation | null;
}
export interface JSXSpreadAttribute extends BaseNode {
	type: "JSXSpreadAttribute";
	argument: Expression;
}
export interface JSXText extends BaseNode {
	type: "JSXText";
	value: string;
}
export interface JSXFragment extends BaseNode {
	type: "JSXFragment";
	openingFragment: JSXOpeningFragment;
	closingFragment: JSXClosingFragment;
	children: Array<JSXText | JSXExpressionContainer | JSXSpreadChild | JSXElement | JSXFragment>;
}
export interface JSXOpeningFragment extends BaseNode {
	type: "JSXOpeningFragment";
}
export interface JSXClosingFragment extends BaseNode {
	type: "JSXClosingFragment";
}
export interface Noop extends BaseNode {
	type: "Noop";
}
export interface Placeholder extends BaseNode {
	type: "Placeholder";
	expectedNode: "Identifier" | "StringLiteral" | "Expression" | "Statement" | "Declaration" | "BlockStatement" | "ClassBody" | "Pattern";
	name: Identifier;
}
export interface V8IntrinsicIdentifier extends BaseNode {
	type: "V8IntrinsicIdentifier";
	name: string;
}
export interface ArgumentPlaceholder extends BaseNode {
	type: "ArgumentPlaceholder";
}
export interface BindExpression extends BaseNode {
	type: "BindExpression";
	object: Expression;
	callee: Expression;
}
export interface ClassProperty extends BaseNode {
	type: "ClassProperty";
	key: Identifier | StringLiteral | NumericLiteral | Expression;
	value?: Expression | null;
	typeAnnotation?: TypeAnnotation | TSTypeAnnotation | Noop | null;
	decorators?: Array<Decorator> | null;
	computed?: boolean;
	static?: boolean;
	abstract?: boolean | null;
	accessibility?: "public" | "private" | "protected" | null;
	declare?: boolean | null;
	definite?: boolean | null;
	optional?: boolean | null;
	readonly?: boolean | null;
}
export interface PipelineTopicExpression extends BaseNode {
	type: "PipelineTopicExpression";
	expression: Expression;
}
export interface PipelineBareFunction extends BaseNode {
	type: "PipelineBareFunction";
	callee: Expression;
}
export interface PipelinePrimaryTopicReference extends BaseNode {
	type: "PipelinePrimaryTopicReference";
}
export interface ClassPrivateProperty extends BaseNode {
	type: "ClassPrivateProperty";
	key: PrivateName;
	value?: Expression | null;
	decorators?: Array<Decorator> | null;
	static: any;
	typeAnnotation?: TypeAnnotation | TSTypeAnnotation | Noop | null;
}
export interface ClassPrivateMethod extends BaseNode {
	type: "ClassPrivateMethod";
	kind?: "get" | "set" | "method" | "constructor";
	key: PrivateName;
	params: Array<Identifier | Pattern | RestElement | TSParameterProperty>;
	body: BlockStatement;
	static?: boolean;
	abstract?: boolean | null;
	access?: "public" | "private" | "protected" | null;
	accessibility?: "public" | "private" | "protected" | null;
	async?: boolean;
	computed?: boolean;
	decorators?: Array<Decorator> | null;
	generator?: boolean;
	optional?: boolean | null;
	returnType?: TypeAnnotation | TSTypeAnnotation | Noop | null;
	typeParameters?: TypeParameterDeclaration | TSTypeParameterDeclaration | Noop | null;
}
export interface ImportAttribute extends BaseNode {
	type: "ImportAttribute";
	key: Identifier | StringLiteral;
	value: StringLiteral;
}
export interface Decorator extends BaseNode {
	type: "Decorator";
	expression: Expression;
}
export interface DoExpression extends BaseNode {
	type: "DoExpression";
	body: BlockStatement;
}
export interface ExportDefaultSpecifier extends BaseNode {
	type: "ExportDefaultSpecifier";
	exported: Identifier;
}
export interface PrivateName extends BaseNode {
	type: "PrivateName";
	id: Identifier;
}
export interface RecordExpression extends BaseNode {
	type: "RecordExpression";
	properties: Array<ObjectProperty | SpreadElement>;
}
export interface TupleExpression extends BaseNode {
	type: "TupleExpression";
	elements: Array<Expression | SpreadElement>;
}
export interface DecimalLiteral extends BaseNode {
	type: "DecimalLiteral";
	value: string;
}
export interface StaticBlock extends BaseNode {
	type: "StaticBlock";
	body: Array<Statement>;
}
export interface TSParameterProperty extends BaseNode {
	type: "TSParameterProperty";
	parameter: Identifier | AssignmentPattern;
	accessibility?: "public" | "private" | "protected" | null;
	readonly?: boolean | null;
}
export interface TSDeclareFunction extends BaseNode {
	type: "TSDeclareFunction";
	id?: Identifier | null;
	typeParameters?: TSTypeParameterDeclaration | Noop | null;
	params: Array<Identifier | Pattern | RestElement | TSParameterProperty>;
	returnType?: TSTypeAnnotation | Noop | null;
	async?: boolean;
	declare?: boolean | null;
	generator?: boolean;
}
export interface TSDeclareMethod extends BaseNode {
	type: "TSDeclareMethod";
	decorators?: Array<Decorator> | null;
	key: Identifier | StringLiteral | NumericLiteral | Expression;
	typeParameters?: TSTypeParameterDeclaration | Noop | null;
	params: Array<Identifier | Pattern | RestElement | TSParameterProperty>;
	returnType?: TSTypeAnnotation | Noop | null;
	abstract?: boolean | null;
	access?: "public" | "private" | "protected" | null;
	accessibility?: "public" | "private" | "protected" | null;
	async?: boolean;
	computed?: boolean;
	generator?: boolean;
	kind?: "get" | "set" | "method" | "constructor";
	optional?: boolean | null;
	static?: boolean;
}
export interface TSQualifiedName extends BaseNode {
	type: "TSQualifiedName";
	left: TSEntityName;
	right: Identifier;
}
export interface TSCallSignatureDeclaration extends BaseNode {
	type: "TSCallSignatureDeclaration";
	typeParameters?: TSTypeParameterDeclaration | null;
	parameters: Array<Identifier | RestElement>;
	typeAnnotation?: TSTypeAnnotation | null;
}
export interface TSConstructSignatureDeclaration extends BaseNode {
	type: "TSConstructSignatureDeclaration";
	typeParameters?: TSTypeParameterDeclaration | null;
	parameters: Array<Identifier | RestElement>;
	typeAnnotation?: TSTypeAnnotation | null;
}
export interface TSPropertySignature extends BaseNode {
	type: "TSPropertySignature";
	key: Expression;
	typeAnnotation?: TSTypeAnnotation | null;
	initializer?: Expression | null;
	computed?: boolean | null;
	optional?: boolean | null;
	readonly?: boolean | null;
}
export interface TSMethodSignature extends BaseNode {
	type: "TSMethodSignature";
	key: Expression;
	typeParameters?: TSTypeParameterDeclaration | null;
	parameters: Array<Identifier | RestElement>;
	typeAnnotation?: TSTypeAnnotation | null;
	computed?: boolean | null;
	optional?: boolean | null;
}
export interface TSIndexSignature extends BaseNode {
	type: "TSIndexSignature";
	parameters: Array<Identifier>;
	typeAnnotation?: TSTypeAnnotation | null;
	readonly?: boolean | null;
}
export interface TSAnyKeyword extends BaseNode {
	type: "TSAnyKeyword";
}
export interface TSBooleanKeyword extends BaseNode {
	type: "TSBooleanKeyword";
}
export interface TSBigIntKeyword extends BaseNode {
	type: "TSBigIntKeyword";
}
export interface TSIntrinsicKeyword extends BaseNode {
	type: "TSIntrinsicKeyword";
}
export interface TSNeverKeyword extends BaseNode {
	type: "TSNeverKeyword";
}
export interface TSNullKeyword extends BaseNode {
	type: "TSNullKeyword";
}
export interface TSNumberKeyword extends BaseNode {
	type: "TSNumberKeyword";
}
export interface TSObjectKeyword extends BaseNode {
	type: "TSObjectKeyword";
}
export interface TSStringKeyword extends BaseNode {
	type: "TSStringKeyword";
}
export interface TSSymbolKeyword extends BaseNode {
	type: "TSSymbolKeyword";
}
export interface TSUndefinedKeyword extends BaseNode {
	type: "TSUndefinedKeyword";
}
export interface TSUnknownKeyword extends BaseNode {
	type: "TSUnknownKeyword";
}
export interface TSVoidKeyword extends BaseNode {
	type: "TSVoidKeyword";
}
export interface TSThisType extends BaseNode {
	type: "TSThisType";
}
export interface TSFunctionType extends BaseNode {
	type: "TSFunctionType";
	typeParameters?: TSTypeParameterDeclaration | null;
	parameters: Array<Identifier | RestElement>;
	typeAnnotation?: TSTypeAnnotation | null;
}
export interface TSConstructorType extends BaseNode {
	type: "TSConstructorType";
	typeParameters?: TSTypeParameterDeclaration | null;
	parameters: Array<Identifier | RestElement>;
	typeAnnotation?: TSTypeAnnotation | null;
}
export interface TSTypeReference extends BaseNode {
	type: "TSTypeReference";
	typeName: TSEntityName;
	typeParameters?: TSTypeParameterInstantiation | null;
}
export interface TSTypePredicate extends BaseNode {
	type: "TSTypePredicate";
	parameterName: Identifier | TSThisType;
	typeAnnotation?: TSTypeAnnotation | null;
	asserts?: boolean | null;
}
export interface TSTypeQuery extends BaseNode {
	type: "TSTypeQuery";
	exprName: TSEntityName | TSImportType;
}
export interface TSTypeLiteral extends BaseNode {
	type: "TSTypeLiteral";
	members: Array<TSTypeElement>;
}
export interface TSArrayType extends BaseNode {
	type: "TSArrayType";
	elementType: TSType;
}
export interface TSTupleType extends BaseNode {
	type: "TSTupleType";
	elementTypes: Array<TSType | TSNamedTupleMember>;
}
export interface TSOptionalType extends BaseNode {
	type: "TSOptionalType";
	typeAnnotation: TSType;
}
export interface TSRestType extends BaseNode {
	type: "TSRestType";
	typeAnnotation: TSType;
}
export interface TSNamedTupleMember extends BaseNode {
	type: "TSNamedTupleMember";
	label: Identifier;
	elementType: TSType;
	optional: boolean;
}
export interface TSUnionType extends BaseNode {
	type: "TSUnionType";
	types: Array<TSType>;
}
export interface TSIntersectionType extends BaseNode {
	type: "TSIntersectionType";
	types: Array<TSType>;
}
export interface TSConditionalType extends BaseNode {
	type: "TSConditionalType";
	checkType: TSType;
	extendsType: TSType;
	trueType: TSType;
	falseType: TSType;
}
export interface TSInferType extends BaseNode {
	type: "TSInferType";
	typeParameter: TSTypeParameter;
}
export interface TSParenthesizedType extends BaseNode {
	type: "TSParenthesizedType";
	typeAnnotation: TSType;
}
export interface TSTypeOperator extends BaseNode {
	type: "TSTypeOperator";
	typeAnnotation: TSType;
	operator: string;
}
export interface TSIndexedAccessType extends BaseNode {
	type: "TSIndexedAccessType";
	objectType: TSType;
	indexType: TSType;
}
export interface TSMappedType extends BaseNode {
	type: "TSMappedType";
	typeParameter: TSTypeParameter;
	typeAnnotation?: TSType | null;
	nameType?: TSType | null;
	optional?: boolean | null;
	readonly?: boolean | null;
}
export interface TSLiteralType extends BaseNode {
	type: "TSLiteralType";
	literal: NumericLiteral | StringLiteral | BooleanLiteral | BigIntLiteral;
}
export interface TSExpressionWithTypeArguments extends BaseNode {
	type: "TSExpressionWithTypeArguments";
	expression: TSEntityName;
	typeParameters?: TSTypeParameterInstantiation | null;
}
export interface TSInterfaceDeclaration extends BaseNode {
	type: "TSInterfaceDeclaration";
	id: Identifier;
	typeParameters?: TSTypeParameterDeclaration | null;
	extends?: Array<TSExpressionWithTypeArguments> | null;
	body: TSInterfaceBody;
	declare?: boolean | null;
}
export interface TSInterfaceBody extends BaseNode {
	type: "TSInterfaceBody";
	body: Array<TSTypeElement>;
}
export interface TSTypeAliasDeclaration extends BaseNode {
	type: "TSTypeAliasDeclaration";
	id: Identifier;
	typeParameters?: TSTypeParameterDeclaration | null;
	typeAnnotation: TSType;
	declare?: boolean | null;
}
export interface TSAsExpression extends BaseNode {
	type: "TSAsExpression";
	expression: Expression;
	typeAnnotation: TSType;
}
export interface TSTypeAssertion extends BaseNode {
	type: "TSTypeAssertion";
	typeAnnotation: TSType;
	expression: Expression;
}
export interface TSEnumDeclaration extends BaseNode {
	type: "TSEnumDeclaration";
	id: Identifier;
	members: Array<TSEnumMember>;
	const?: boolean | null;
	declare?: boolean | null;
	initializer?: Expression | null;
}
export interface TSEnumMember extends BaseNode {
	type: "TSEnumMember";
	id: Identifier | StringLiteral;
	initializer?: Expression | null;
}
export interface TSModuleDeclaration extends BaseNode {
	type: "TSModuleDeclaration";
	id: Identifier | StringLiteral;
	body: TSModuleBlock | TSModuleDeclaration;
	declare?: boolean | null;
	global?: boolean | null;
}
export interface TSModuleBlock extends BaseNode {
	type: "TSModuleBlock";
	body: Array<Statement>;
}
export interface TSImportType extends BaseNode {
	type: "TSImportType";
	argument: StringLiteral;
	qualifier?: TSEntityName | null;
	typeParameters?: TSTypeParameterInstantiation | null;
}
export interface TSImportEqualsDeclaration extends BaseNode {
	type: "TSImportEqualsDeclaration";
	id: Identifier;
	moduleReference: TSEntityName | TSExternalModuleReference;
	isExport: boolean;
}
export interface TSExternalModuleReference extends BaseNode {
	type: "TSExternalModuleReference";
	expression: StringLiteral;
}
export interface TSNonNullExpression extends BaseNode {
	type: "TSNonNullExpression";
	expression: Expression;
}
export interface TSExportAssignment extends BaseNode {
	type: "TSExportAssignment";
	expression: Expression;
}
export interface TSNamespaceExportDeclaration extends BaseNode {
	type: "TSNamespaceExportDeclaration";
	id: Identifier;
}
export interface TSTypeAnnotation extends BaseNode {
	type: "TSTypeAnnotation";
	typeAnnotation: TSType;
}
export interface TSTypeParameterInstantiation extends BaseNode {
	type: "TSTypeParameterInstantiation";
	params: Array<TSType>;
}
export interface TSTypeParameterDeclaration extends BaseNode {
	type: "TSTypeParameterDeclaration";
	params: Array<TSTypeParameter>;
}
export interface TSTypeParameter extends BaseNode {
	type: "TSTypeParameter";
	constraint?: TSType | null;
	default?: TSType | null;
	name: string;
}
export declare type Expression = ArrayExpression | AssignmentExpression | BinaryExpression | CallExpression | ConditionalExpression | FunctionExpression | Identifier | StringLiteral | NumericLiteral | NullLiteral | BooleanLiteral | RegExpLiteral | LogicalExpression | MemberExpression | NewExpression | ObjectExpression | SequenceExpression | ParenthesizedExpression | ThisExpression | UnaryExpression | UpdateExpression | ArrowFunctionExpression | ClassExpression | MetaProperty | Super | TaggedTemplateExpression | TemplateLiteral | YieldExpression | AwaitExpression | Import | BigIntLiteral | OptionalMemberExpression | OptionalCallExpression | TypeCastExpression | JSXElement | JSXFragment | BindExpression | PipelinePrimaryTopicReference | DoExpression | RecordExpression | TupleExpression | DecimalLiteral | TSAsExpression | TSTypeAssertion | TSNonNullExpression;
export declare type Binary = BinaryExpression | LogicalExpression;
export declare type Scopable = BlockStatement | CatchClause | DoWhileStatement | ForInStatement | ForStatement | FunctionDeclaration | FunctionExpression | Program | ObjectMethod | SwitchStatement | WhileStatement | ArrowFunctionExpression | ClassExpression | ClassDeclaration | ForOfStatement | ClassMethod | ClassPrivateMethod | StaticBlock | TSModuleBlock;
export declare type BlockParent = BlockStatement | CatchClause | DoWhileStatement | ForInStatement | ForStatement | FunctionDeclaration | FunctionExpression | Program | ObjectMethod | SwitchStatement | WhileStatement | ArrowFunctionExpression | ForOfStatement | ClassMethod | ClassPrivateMethod | StaticBlock | TSModuleBlock;
export declare type Block = BlockStatement | Program | TSModuleBlock;
export declare type Statement = BlockStatement | BreakStatement | ContinueStatement | DebuggerStatement | DoWhileStatement | EmptyStatement | ExpressionStatement | ForInStatement | ForStatement | FunctionDeclaration | IfStatement | LabeledStatement | ReturnStatement | SwitchStatement | ThrowStatement | TryStatement | VariableDeclaration | WhileStatement | WithStatement | ClassDeclaration | ExportAllDeclaration | ExportDefaultDeclaration | ExportNamedDeclaration | ForOfStatement | ImportDeclaration | DeclareClass | DeclareFunction | DeclareInterface | DeclareModule | DeclareModuleExports | DeclareTypeAlias | DeclareOpaqueType | DeclareVariable | DeclareExportDeclaration | DeclareExportAllDeclaration | InterfaceDeclaration | OpaqueType | TypeAlias | EnumDeclaration | TSDeclareFunction | TSInterfaceDeclaration | TSTypeAliasDeclaration | TSEnumDeclaration | TSModuleDeclaration | TSImportEqualsDeclaration | TSExportAssignment | TSNamespaceExportDeclaration;
export declare type Terminatorless = BreakStatement | ContinueStatement | ReturnStatement | ThrowStatement | YieldExpression | AwaitExpression;
export declare type CompletionStatement = BreakStatement | ContinueStatement | ReturnStatement | ThrowStatement;
export declare type Conditional = ConditionalExpression | IfStatement;
export declare type Loop = DoWhileStatement | ForInStatement | ForStatement | WhileStatement | ForOfStatement;
export declare type While = DoWhileStatement | WhileStatement;
export declare type ExpressionWrapper = ExpressionStatement | ParenthesizedExpression | TypeCastExpression;
export declare type For = ForInStatement | ForStatement | ForOfStatement;
export declare type ForXStatement = ForInStatement | ForOfStatement;
export declare type Function = FunctionDeclaration | FunctionExpression | ObjectMethod | ArrowFunctionExpression | ClassMethod | ClassPrivateMethod;
export declare type FunctionParent = FunctionDeclaration | FunctionExpression | ObjectMethod | ArrowFunctionExpression | ClassMethod | ClassPrivateMethod;
export declare type Pureish = FunctionDeclaration | FunctionExpression | StringLiteral | NumericLiteral | NullLiteral | BooleanLiteral | RegExpLiteral | ArrowFunctionExpression | BigIntLiteral | DecimalLiteral;
export declare type Declaration = FunctionDeclaration | VariableDeclaration | ClassDeclaration | ExportAllDeclaration | ExportDefaultDeclaration | ExportNamedDeclaration | ImportDeclaration | DeclareClass | DeclareFunction | DeclareInterface | DeclareModule | DeclareModuleExports | DeclareTypeAlias | DeclareOpaqueType | DeclareVariable | DeclareExportDeclaration | DeclareExportAllDeclaration | InterfaceDeclaration | OpaqueType | TypeAlias | EnumDeclaration | TSDeclareFunction | TSInterfaceDeclaration | TSTypeAliasDeclaration | TSEnumDeclaration | TSModuleDeclaration;
export declare type PatternLike = Identifier | RestElement | AssignmentPattern | ArrayPattern | ObjectPattern;
export declare type LVal = Identifier | MemberExpression | RestElement | AssignmentPattern | ArrayPattern | ObjectPattern | TSParameterProperty;
export declare type TSEntityName = Identifier | TSQualifiedName;
export declare type Literal = StringLiteral | NumericLiteral | NullLiteral | BooleanLiteral | RegExpLiteral | TemplateLiteral | BigIntLiteral | DecimalLiteral;
export declare type Immutable = StringLiteral | NumericLiteral | NullLiteral | BooleanLiteral | BigIntLiteral | JSXAttribute | JSXClosingElement | JSXElement | JSXExpressionContainer | JSXSpreadChild | JSXOpeningElement | JSXText | JSXFragment | JSXOpeningFragment | JSXClosingFragment | DecimalLiteral;
export declare type UserWhitespacable = ObjectMethod | ObjectProperty | ObjectTypeInternalSlot | ObjectTypeCallProperty | ObjectTypeIndexer | ObjectTypeProperty | ObjectTypeSpreadProperty;
export declare type Method = ObjectMethod | ClassMethod | ClassPrivateMethod;
export declare type ObjectMember = ObjectMethod | ObjectProperty;
export declare type Property = ObjectProperty | ClassProperty | ClassPrivateProperty;
export declare type UnaryLike = UnaryExpression | SpreadElement;
export declare type Pattern = AssignmentPattern | ArrayPattern | ObjectPattern;
export declare type Class = ClassExpression | ClassDeclaration;
export declare type ModuleDeclaration = ExportAllDeclaration | ExportDefaultDeclaration | ExportNamedDeclaration | ImportDeclaration;
export declare type ExportDeclaration = ExportAllDeclaration | ExportDefaultDeclaration | ExportNamedDeclaration;
export declare type ModuleSpecifier = ExportSpecifier | ImportDefaultSpecifier | ImportNamespaceSpecifier | ImportSpecifier | ExportNamespaceSpecifier | ExportDefaultSpecifier;
export declare type Flow = AnyTypeAnnotation | ArrayTypeAnnotation | BooleanTypeAnnotation | BooleanLiteralTypeAnnotation | NullLiteralTypeAnnotation | ClassImplements | DeclareClass | DeclareFunction | DeclareInterface | DeclareModule | DeclareModuleExports | DeclareTypeAlias | DeclareOpaqueType | DeclareVariable | DeclareExportDeclaration | DeclareExportAllDeclaration | DeclaredPredicate | ExistsTypeAnnotation | FunctionTypeAnnotation | FunctionTypeParam | GenericTypeAnnotation | InferredPredicate | InterfaceExtends | InterfaceDeclaration | InterfaceTypeAnnotation | IntersectionTypeAnnotation | MixedTypeAnnotation | EmptyTypeAnnotation | NullableTypeAnnotation | NumberLiteralTypeAnnotation | NumberTypeAnnotation | ObjectTypeAnnotation | ObjectTypeInternalSlot | ObjectTypeCallProperty | ObjectTypeIndexer | ObjectTypeProperty | ObjectTypeSpreadProperty | OpaqueType | QualifiedTypeIdentifier | StringLiteralTypeAnnotation | StringTypeAnnotation | SymbolTypeAnnotation | ThisTypeAnnotation | TupleTypeAnnotation | TypeofTypeAnnotation | TypeAlias | TypeAnnotation | TypeCastExpression | TypeParameter | TypeParameterDeclaration | TypeParameterInstantiation | UnionTypeAnnotation | Variance | VoidTypeAnnotation;
export declare type FlowType = AnyTypeAnnotation | ArrayTypeAnnotation | BooleanTypeAnnotation | BooleanLiteralTypeAnnotation | NullLiteralTypeAnnotation | ExistsTypeAnnotation | FunctionTypeAnnotation | GenericTypeAnnotation | InterfaceTypeAnnotation | IntersectionTypeAnnotation | MixedTypeAnnotation | EmptyTypeAnnotation | NullableTypeAnnotation | NumberLiteralTypeAnnotation | NumberTypeAnnotation | ObjectTypeAnnotation | StringLiteralTypeAnnotation | StringTypeAnnotation | SymbolTypeAnnotation | ThisTypeAnnotation | TupleTypeAnnotation | TypeofTypeAnnotation | UnionTypeAnnotation | VoidTypeAnnotation;
export declare type FlowBaseAnnotation = AnyTypeAnnotation | BooleanTypeAnnotation | NullLiteralTypeAnnotation | MixedTypeAnnotation | EmptyTypeAnnotation | NumberTypeAnnotation | StringTypeAnnotation | SymbolTypeAnnotation | ThisTypeAnnotation | VoidTypeAnnotation;
export declare type FlowDeclaration = DeclareClass | DeclareFunction | DeclareInterface | DeclareModule | DeclareModuleExports | DeclareTypeAlias | DeclareOpaqueType | DeclareVariable | DeclareExportDeclaration | DeclareExportAllDeclaration | InterfaceDeclaration | OpaqueType | TypeAlias;
export declare type FlowPredicate = DeclaredPredicate | InferredPredicate;
export declare type EnumBody = EnumBooleanBody | EnumNumberBody | EnumStringBody | EnumSymbolBody;
export declare type EnumMember = EnumBooleanMember | EnumNumberMember | EnumStringMember | EnumDefaultedMember;
export declare type JSX = JSXAttribute | JSXClosingElement | JSXElement | JSXEmptyExpression | JSXExpressionContainer | JSXSpreadChild | JSXIdentifier | JSXMemberExpression | JSXNamespacedName | JSXOpeningElement | JSXSpreadAttribute | JSXText | JSXFragment | JSXOpeningFragment | JSXClosingFragment;
export declare type Private = ClassPrivateProperty | ClassPrivateMethod | PrivateName;
export declare type TSTypeElement = TSCallSignatureDeclaration | TSConstructSignatureDeclaration | TSPropertySignature | TSMethodSignature | TSIndexSignature;
export declare type TSType = TSAnyKeyword | TSBooleanKeyword | TSBigIntKeyword | TSIntrinsicKeyword | TSNeverKeyword | TSNullKeyword | TSNumberKeyword | TSObjectKeyword | TSStringKeyword | TSSymbolKeyword | TSUndefinedKeyword | TSUnknownKeyword | TSVoidKeyword | TSThisType | TSFunctionType | TSConstructorType | TSTypeReference | TSTypePredicate | TSTypeQuery | TSTypeLiteral | TSArrayType | TSTupleType | TSOptionalType | TSRestType | TSUnionType | TSIntersectionType | TSConditionalType | TSInferType | TSParenthesizedType | TSTypeOperator | TSIndexedAccessType | TSMappedType | TSLiteralType | TSExpressionWithTypeArguments | TSImportType;
export declare type TSBaseType = TSAnyKeyword | TSBooleanKeyword | TSBigIntKeyword | TSIntrinsicKeyword | TSNeverKeyword | TSNullKeyword | TSNumberKeyword | TSObjectKeyword | TSStringKeyword | TSSymbolKeyword | TSUndefinedKeyword | TSUnknownKeyword | TSVoidKeyword | TSThisType | TSLiteralType;
export interface Aliases {
	Expression: Expression;
	Binary: Binary;
	Scopable: Scopable;
	BlockParent: BlockParent;
	Block: Block;
	Statement: Statement;
	Terminatorless: Terminatorless;
	CompletionStatement: CompletionStatement;
	Conditional: Conditional;
	Loop: Loop;
	While: While;
	ExpressionWrapper: ExpressionWrapper;
	For: For;
	ForXStatement: ForXStatement;
	Function: Function;
	FunctionParent: FunctionParent;
	Pureish: Pureish;
	Declaration: Declaration;
	PatternLike: PatternLike;
	LVal: LVal;
	TSEntityName: TSEntityName;
	Literal: Literal;
	Immutable: Immutable;
	UserWhitespacable: UserWhitespacable;
	Method: Method;
	ObjectMember: ObjectMember;
	Property: Property;
	UnaryLike: UnaryLike;
	Pattern: Pattern;
	Class: Class;
	ModuleDeclaration: ModuleDeclaration;
	ExportDeclaration: ExportDeclaration;
	ModuleSpecifier: ModuleSpecifier;
	Flow: Flow;
	FlowType: FlowType;
	FlowBaseAnnotation: FlowBaseAnnotation;
	FlowDeclaration: FlowDeclaration;
	FlowPredicate: FlowPredicate;
	EnumBody: EnumBody;
	EnumMember: EnumMember;
	JSX: JSX;
	Private: Private;
	TSTypeElement: TSTypeElement;
	TSType: TSType;
	TSBaseType: TSBaseType;
}
declare const traverse: {
	<S>(parent: Node | Node[] | null | undefined, opts: TraverseOptions<S>, scope: Scope | undefined, state: S, parentPath?: NodePath): void;
	(parent: Node | Node[] | null | undefined, opts?: TraverseOptions, scope?: Scope, state?: any, parentPath?: NodePath): void;
	visitors: typeof visitors;
	verify: typeof visitors.verify;
	explode: typeof visitors.explode;
};
export namespace visitors {
	/**
	 * `explode()` will take a `Visitor` object with all of the various shorthands
	 * that we support, and validates & normalizes it into a common format, ready
	 * to be used in traversal.
	 *
	 * The various shorthands are:
	 * - `Identifier() { ... }` -> `Identifier: { enter() { ... } }`
	 * - `"Identifier|NumericLiteral": { ... }` -> `Identifier: { ... }, NumericLiteral: { ... }`
	 * - Aliases in `@babel/types`: e.g. `Property: { ... }` -> `ObjectProperty: { ... }, ClassProperty: { ... }`
	 *
	 * Other normalizations are:
	 * - Visitors of virtual types are wrapped, so that they are only visited when their dynamic check passes
	 * - `enter` and `exit` functions are wrapped in arrays, to ease merging of visitors
	 */
	function explode<S = {}>(visitor: Visitor<S>): {
		[Type in Node["type"]]?: VisitNodeObject<S, Extract<Node, {
			type: Type;
		}>>;
	};
	function verify(visitor: Visitor): void;
	function merge<S = {}>(visitors: Array<Visitor<S>>, states?: S[]): Visitor<unknown>;
}
export interface TraverseOptions<S = Node> extends Visitor<S> {
	scope?: Scope;
	noScope?: boolean;
}
export type ArrayKeys<T> = {
	[P in keyof T]: T[P] extends any[] ? P : never;
}[keyof T];
declare class Scope {
	constructor(path: NodePath, parentScope?: Scope);
	path: NodePath;
	block: Node;
	parentBlock: Node;
	parent: Scope;
	hub: HubInterface;
	bindings: {
		[name: string]: Binding;
	};
	/** Traverse node with current scope and path. */
	traverse<S>(node: Node | Node[], opts: TraverseOptions<S>, state: S): void;
	traverse(node: Node | Node[], opts?: TraverseOptions, state?: any): void;
	/** Generate a unique identifier and add it to the current scope. */
	generateDeclaredUidIdentifier(name?: string): t.Identifier;
	/** Generate a unique identifier. */
	generateUidIdentifier(name?: string): t.Identifier;
	/** Generate a unique `_id1` binding. */
	generateUid(name?: string): string;
	/** Generate a unique identifier based on a node. */
	generateUidIdentifierBasedOnNode(parent: Node, defaultName?: string): t.Identifier;
	/**
	 * Determine whether evaluating the specific input `node` is a consequenceless reference. ie.
	 * evaluating it wont result in potentially arbitrary code from being ran. The following are
	 * whitelisted and determined not to cause side effects:
	 *
	 *  - `this` expressions
	 *  - `super` expressions
	 *  - Bound identifiers
	 */
	isStatic(node: Node): boolean;
	/** Possibly generate a memoised identifier if it is not static and has consequences. */
	maybeGenerateMemoised(node: Node, dontPush?: boolean): t.Identifier;
	checkBlockScopedCollisions(local: Node, kind: string, name: string, id: object): void;
	rename(oldName: string, newName?: string, block?: Node): void;
	dump(): void;
	toArray(node: Node, i?: number): Node;
	registerDeclaration(path: NodePath): void;
	buildUndefinedNode(): Node;
	registerConstantViolation(path: NodePath): void;
	registerBinding(kind: string, path: NodePath, bindingPath?: NodePath): void;
	addGlobal(node: Node): void;
	hasUid(name: string): boolean;
	hasGlobal(name: string): boolean;
	hasReference(name: string): boolean;
	isPure(node: Node, constantsOnly?: boolean): boolean;
	setData(key: string, val: any): any;
	getData(key: string): any;
	removeData(key: string): void;
	crawl(): void;
	push(opts: {
		id: t.LVal;
		init?: t.Expression;
		unique?: boolean;
		kind?: "var" | "let" | "const";
	}): void;
	getProgramParent(): Scope;
	getFunctionParent(): Scope | null;
	getBlockParent(): Scope;
	/** Walks the scope tree and gathers **all** bindings. */
	getAllBindings(...kinds: string[]): object;
	bindingIdentifierEquals(name: string, node: Node): boolean;
	getBinding(name: string): Binding | undefined;
	getOwnBinding(name: string): Binding | undefined;
	getBindingIdentifier(name: string): t.Identifier;
	getOwnBindingIdentifier(name: string): t.Identifier;
	hasOwnBinding(name: string): boolean;
	hasBinding(name: string, noGlobals?: boolean): boolean;
	parentHasBinding(name: string, noGlobals?: boolean): boolean;
	/** Move a binding of `name` to another `scope`. */
	moveBindingTo(name: string, scope: Scope): void;
	removeOwnBinding(name: string): void;
	removeBinding(name: string): void;
}
declare class Binding {
	constructor(opts: {
		existing: Binding;
		identifier: t.Identifier;
		scope: Scope;
		path: NodePath;
		kind: "var" | "let" | "const";
	});
	identifier: t.Identifier;
	scope: Scope;
	path: NodePath;
	kind: "var" | "let" | "const" | "module";
	referenced: boolean;
	references: number;
	referencePaths: NodePath[];
	constant: boolean;
	constantViolations: NodePath[];
}
export type Visitor<S = {}> = VisitNodeObject<S, Node> & {
	[Type in Node["type"]]?: VisitNode<S, Extract<Node, {
		type: Type;
	}>>;
} & {
	[K in keyof t.Aliases]?: VisitNode<S, t.Aliases[K]>;
};
export type VisitNode<S, P extends Node> = VisitNodeFunction<S, P> | VisitNodeObject<S, P>;
export type VisitNodeFunction<S, P extends Node> = (this: S, path: NodePath<P>, state: S) => void;
export type NodeType = Node["type"] | keyof t.Aliases;
export interface VisitNodeObject<S, P extends Node> {
	enter?: VisitNodeFunction<S, P>;
	exit?: VisitNodeFunction<S, P>;
	denylist?: NodeType[];
	/**
	 * @deprecated will be removed in Babel 8
	 */
	blacklist?: NodeType[];
}
export type NodePaths<T extends Node | readonly Node[]> = T extends readonly Node[] ? {
	-readonly [K in keyof T]: NodePath<Extract<T[K], Node>>;
} : T extends Node ? [
	NodePath<T>
] : never;
declare class NodePath<T = Node> {
	constructor(hub: Hub, parent: Node);
	parent: Node;
	hub: Hub;
	contexts: TraversalContext[];
	data: object;
	shouldSkip: boolean;
	shouldStop: boolean;
	removed: boolean;
	state: any;
	opts: object;
	skipKeys: object;
	parentPath: NodePath;
	context: TraversalContext;
	container: object | object[];
	listKey: string;
	inList: boolean;
	parentKey: string;
	key: string | number;
	node: T;
	scope: Scope;
	type: T extends null | undefined ? undefined : T extends Node ? T["type"] : string | undefined;
	typeAnnotation: object;
	getScope(scope: Scope): Scope;
	setData(key: string, val: any): any;
	getData(key: string, def?: any): any;
	buildCodeFrameError<TError extends Error>(msg: string, Error?: new (msg: string) => TError): TError;
	traverse<T>(visitor: Visitor<T>, state: T): void;
	traverse(visitor: Visitor): void;
	set(key: string, node: Node): void;
	getPathLocation(): string;
	// Example: https://github.com/babel/babel/blob/63204ae51e020d84a5b246312f5eeb4d981ab952/packages/babel-traverse/src/path/modification.js#L83
	debug(buildMessage: () => string): void;
	static get<C extends Node, K extends keyof C>(opts: {
		hub: HubInterface;
		parentPath: NodePath | null;
		parent: Node;
		container: C;
		listKey?: string;
		key: K;
	}): NodePath<C[K]>;
	//#region ------------------------- ancestry -------------------------
	/**
	 * Starting at the parent path of the current `NodePath` and going up the
	 * tree, return the first `NodePath` that causes the provided `callback`
	 * to return a truthy value, or `null` if the `callback` never returns a
	 * truthy value.
	 */
	findParent(callback: (path: NodePath) => boolean): NodePath | null;
	/**
	 * Starting at current `NodePath` and going up the tree, return the first
	 * `NodePath` that causes the provided `callback` to return a truthy value,
	 * or `null` if the `callback` never returns a truthy value.
	 */
	find(callback: (path: NodePath) => boolean): NodePath | null;
	/** Get the parent function of the current path. */
	getFunctionParent(): NodePath<t.Function> | null;
	/** Walk up the tree until we hit a parent node path in a list. */
	getStatementParent(): NodePath<t.Statement> | null;
	/**
	 * Get the deepest common ancestor and then from it, get the earliest relationship path
	 * to that ancestor.
	 *
	 * Earliest is defined as being "before" all the other nodes in terms of list container
	 * position and visiting key.
	 */
	getEarliestCommonAncestorFrom(paths: NodePath[]): NodePath;
	/** Get the earliest path in the tree where the provided `paths` intersect. */
	getDeepestCommonAncestorFrom(paths: NodePath[], filter?: (deepest: Node, i: number, ancestries: NodePath[]) => NodePath): NodePath;
	/**
	 * Build an array of node paths containing the entire ancestry of the current node path.
	 *
	 * NOTE: The current node path is included in this.
	 */
	getAncestry(): [
		this,
		...NodePath[]
	];
	/**
	 * A helper to find if `this` path is an ancestor of `maybeDescendant`
	 */
	isAncestor(maybeDescendant: NodePath): boolean;
	/**
	 * A helper to find if `this` path is a descendant of `maybeAncestor`
	 */
	isDescendant(maybeAncestor: NodePath): boolean;
	inType(...candidateTypes: string[]): boolean;
	//#endregion
	//#region ------------------------- inference -------------------------
	/** Infer the type of the current `NodePath`. */
	getTypeAnnotation(): t.FlowType;
	isBaseType(baseName: string, soft?: boolean): boolean;
	couldBeBaseType(name: string): boolean;
	baseTypeStrictlyMatches(right: NodePath): boolean;
	isGenericType(genericName: string): boolean;
	//#endregion
	//#region ------------------------- replacement -------------------------
	/**
	 * Replace a node with an array of multiple. This method performs the following steps:
	 *
	 *  - Inherit the comments of first provided node with that of the current node.
	 *  - Insert the provided nodes after the current node.
	 *  - Remove the current node.
	 */
	replaceWithMultiple<Nodes extends readonly Node[]>(nodes: Nodes): NodePaths<Nodes>;
	/**
	 * Parse a string as an expression and replace the current node with the result.
	 *
	 * NOTE: This is typically not a good idea to use. Building source strings when
	 * transforming ASTs is an antipattern and SHOULD NOT be encouraged. Even if it's
	 * easier to use, your transforms will be extremely brittle.
	 */
	replaceWithSourceString(replacement: any): [
		NodePath
	];
	/** Replace the current node with another. */
	replaceWith<T extends Node>(replacement: T | NodePath<T>): [
		NodePath<T>
	];
	/**
	 * This method takes an array of statements nodes and then explodes it
	 * into expressions. This method retains completion records which is
	 * extremely important to retain original semantics.
	 */
	replaceExpressionWithStatements<Nodes extends readonly Node[]>(nodes: Nodes): NodePaths<Nodes>;
	replaceInline<Nodes extends Node | readonly Node[]>(nodes: Nodes): NodePaths<Nodes>;
	//#endregion
	//#region ------------------------- evaluation -------------------------
	/**
	 * Walk the input `node` and statically evaluate if it's truthy.
	 *
	 * Returning `true` when we're sure that the expression will evaluate to a
	 * truthy value, `false` if we're sure that it will evaluate to a falsy
	 * value and `undefined` if we aren't sure. Because of this please do not
	 * rely on coercion when using this method and check with === if it's false.
	 */
	evaluateTruthy(): boolean;
	/**
	 * Walk the input `node` and statically evaluate it.
	 *
	 * Returns an object in the form `{ confident, value }`. `confident` indicates
	 * whether or not we had to drop out of evaluating the expression because of
	 * hitting an unknown node that we couldn't confidently find the value of.
	 *
	 * Example:
	 *
	 *   t.evaluate(parse("5 + 5")) // { confident: true, value: 10 }
	 *   t.evaluate(parse("!true")) // { confident: true, value: false }
	 *   t.evaluate(parse("foo + foo")) // { confident: false, value: undefined }
	 */
	evaluate(): {
		confident: boolean;
		value: any;
	};
	//#endregion
	//#region ------------------------- introspection -------------------------
	/**
	 * Match the current node if it matches the provided `pattern`.
	 *
	 * For example, given the match `React.createClass` it would match the
	 * parsed nodes of `React.createClass` and `React["createClass"]`.
	 */
	matchesPattern(pattern: string, allowPartial?: boolean): boolean;
	/**
	 * Check whether we have the input `key`. If the `key` references an array then we check
	 * if the array has any items, otherwise we just check if it's falsy.
	 */
	has(key: string): boolean;
	isStatic(): boolean;
	/** Alias of `has`. */
	is(key: string): boolean;
	/** Opposite of `has`. */
	isnt(key: string): boolean;
	/** Check whether the path node `key` strict equals `value`. */
	equals(key: string, value: any): boolean;
	/**
	 * Check the type against our stored internal type of the node. This is handy when a node has
	 * been removed yet we still internally know the type and need it to calculate node replacement.
	 */
	isNodeType(type: string): boolean;
	/**
	 * This checks whether or not we're in one of the following positions:
	 *
	 *   for (KEY in right);
	 *   for (KEY;;);
	 *
	 * This is because these spots allow VariableDeclarations AND normal expressions so we need
	 * to tell the path replacement that it's ok to replace this with an expression.
	 */
	canHaveVariableDeclarationOrExpression(): boolean;
	/**
	 * This checks whether we are swapping an arrow function's body between an
	 * expression and a block statement (or vice versa).
	 *
	 * This is because arrow functions may implicitly return an expression, which
	 * is the same as containing a block statement.
	 */
	canSwapBetweenExpressionAndStatement(replacement: Node): boolean;
	/** Check whether the current path references a completion record */
	isCompletionRecord(allowInsideFunction?: boolean): boolean;
	/**
	 * Check whether or not the current `key` allows either a single statement or block statement
	 * so we can explode it if necessary.
	 */
	isStatementOrBlock(): boolean;
	/** Check if the currently assigned path references the `importName` of `moduleSource`. */
	referencesImport(moduleSource: string, importName: string): boolean;
	/** Get the source code associated with this node. */
	getSource(): string;
	/** Check if the current path will maybe execute before another path */
	willIMaybeExecuteBefore(path: NodePath): boolean;
	//#endregion
	//#region ------------------------- context -------------------------
	call(key: string): boolean;
	isBlacklisted(): boolean;
	visit(): boolean;
	skip(): void;
	skipKey(key: string): void;
	stop(): void;
	setScope(): void;
	setContext(context: TraversalContext): NodePath<T>;
	popContext(): void;
	pushContext(context: TraversalContext): void;
	//#endregion
	//#region ------------------------- removal -------------------------
	remove(): void;
	//#endregion
	//#region ------------------------- modification -------------------------
	/** Insert the provided nodes before the current one. */
	insertBefore<Nodes extends Node | readonly Node[]>(nodes: Nodes): NodePaths<Nodes>;
	/**
	 * Insert the provided nodes after the current one. When inserting nodes after an
	 * expression, ensure that the completion record is correct by pushing the current node.
	 */
	insertAfter<Nodes extends Node | readonly Node[]>(nodes: Nodes): NodePaths<Nodes>;
	/** Update all sibling node paths after `fromIndex` by `incrementBy`. */
	updateSiblingKeys(fromIndex: number, incrementBy: number): void;
	/**
	 * Insert child nodes at the start of the current node.
	 * @param listKey - The key at which the child nodes are stored (usually body).
	 * @param nodes - the nodes to insert.
	 */
	unshiftContainer<Nodes extends Node | readonly Node[]>(listKey: ArrayKeys<T>, nodes: Nodes): NodePaths<Nodes>;
	/**
	 * Insert child nodes at the end of the current node.
	 * @param listKey - The key at which the child nodes are stored (usually body).
	 * @param nodes - the nodes to insert.
	 */
	pushContainer<Nodes extends Node | readonly Node[]>(listKey: ArrayKeys<T>, nodes: Nodes): NodePaths<Nodes>;
	/** Hoist the current node to the highest scope possible and return a UID referencing it. */
	hoist(scope: Scope): void;
	//#endregion
	//#region ------------------------- family -------------------------
	getOpposite(): NodePath;
	getCompletionRecords(): NodePath[];
	getSibling(key: string | number): NodePath;
	getAllPrevSiblings(): NodePath[];
	getAllNextSiblings(): NodePath[];
	get<K extends keyof T>(key: K, context?: boolean | TraversalContext): T[K] extends Array<Node | null | undefined> ? Array<NodePath<T[K][number]>> : T[K] extends Node | null | undefined ? NodePath<T[K]> : never;
	get(key: string, context?: boolean | TraversalContext): NodePath | NodePath[];
	getBindingIdentifiers(duplicates?: boolean): Node[];
	getOuterBindingIdentifiers(duplicates?: boolean): Node[];
	//#endregion
	//#region ------------------------- comments -------------------------
	/** Share comments amongst siblings. */
	shareCommentsWithSiblings(): void;
	addComment(type: string, content: string, line?: boolean): void;
	/** Give node `comments` of the specified `type`. */
	addComments(type: string, comments: any[]): void;
	//#endregion
	//#region ------------------------- isXXX -------------------------
	isAnyTypeAnnotation(props?: object | null): this is NodePath<t.AnyTypeAnnotation>;
	isArrayExpression(props?: object | null): this is NodePath<t.ArrayExpression>;
	isArrayPattern(props?: object | null): this is NodePath<t.ArrayPattern>;
	isArrayTypeAnnotation(props?: object | null): this is NodePath<t.ArrayTypeAnnotation>;
	isArrowFunctionExpression(props?: object | null): this is NodePath<t.ArrowFunctionExpression>;
	isAssignmentExpression(props?: object | null): this is NodePath<t.AssignmentExpression>;
	isAssignmentPattern(props?: object | null): this is NodePath<t.AssignmentPattern>;
	isAwaitExpression(props?: object | null): this is NodePath<t.AwaitExpression>;
	isBigIntLiteral(props?: object | null): this is NodePath<t.BigIntLiteral>;
	isBinary(props?: object | null): this is NodePath<t.Binary>;
	isBinaryExpression(props?: object | null): this is NodePath<t.BinaryExpression>;
	isBindExpression(props?: object | null): this is NodePath<t.BindExpression>;
	isBlock(props?: object | null): this is NodePath<t.Block>;
	isBlockParent(props?: object | null): this is NodePath<t.BlockParent>;
	isBlockStatement(props?: object | null): this is NodePath<t.BlockStatement>;
	isBooleanLiteral(props?: object | null): this is NodePath<t.BooleanLiteral>;
	isBooleanLiteralTypeAnnotation(props?: object | null): this is NodePath<t.BooleanLiteralTypeAnnotation>;
	isBooleanTypeAnnotation(props?: object | null): this is NodePath<t.BooleanTypeAnnotation>;
	isBreakStatement(props?: object | null): this is NodePath<t.BreakStatement>;
	isCallExpression(props?: object | null): this is NodePath<t.CallExpression>;
	isCatchClause(props?: object | null): this is NodePath<t.CatchClause>;
	isClass(props?: object | null): this is NodePath<t.Class>;
	isClassBody(props?: object | null): this is NodePath<t.ClassBody>;
	isClassDeclaration(props?: object | null): this is NodePath<t.ClassDeclaration>;
	isClassExpression(props?: object | null): this is NodePath<t.ClassExpression>;
	isClassImplements(props?: object | null): this is NodePath<t.ClassImplements>;
	isClassMethod(props?: object | null): this is NodePath<t.ClassMethod>;
	isClassPrivateMethod(props?: object | null): this is NodePath<t.ClassPrivateMethod>;
	isClassPrivateProperty(props?: object | null): this is NodePath<t.ClassPrivateProperty>;
	isClassProperty(props?: object | null): this is NodePath<t.ClassProperty>;
	isCompletionStatement(props?: object | null): this is NodePath<t.CompletionStatement>;
	isConditional(props?: object | null): this is NodePath<t.Conditional>;
	isConditionalExpression(props?: object | null): this is NodePath<t.ConditionalExpression>;
	isContinueStatement(props?: object | null): this is NodePath<t.ContinueStatement>;
	isDebuggerStatement(props?: object | null): this is NodePath<t.DebuggerStatement>;
	isDeclaration(props?: object | null): this is NodePath<t.Declaration>;
	isDeclareClass(props?: object | null): this is NodePath<t.DeclareClass>;
	isDeclareExportAllDeclaration(props?: object | null): this is NodePath<t.DeclareExportAllDeclaration>;
	isDeclareExportDeclaration(props?: object | null): this is NodePath<t.DeclareExportDeclaration>;
	isDeclareFunction(props?: object | null): this is NodePath<t.DeclareFunction>;
	isDeclareInterface(props?: object | null): this is NodePath<t.DeclareInterface>;
	isDeclareModule(props?: object | null): this is NodePath<t.DeclareModule>;
	isDeclareModuleExports(props?: object | null): this is NodePath<t.DeclareModuleExports>;
	isDeclareOpaqueType(props?: object | null): this is NodePath<t.DeclareOpaqueType>;
	isDeclareTypeAlias(props?: object | null): this is NodePath<t.DeclareTypeAlias>;
	isDeclareVariable(props?: object | null): this is NodePath<t.DeclareVariable>;
	isDeclaredPredicate(props?: object | null): this is NodePath<t.DeclaredPredicate>;
	isDecorator(props?: object | null): this is NodePath<t.Decorator>;
	isDirective(props?: object | null): this is NodePath<t.Directive>;
	isDirectiveLiteral(props?: object | null): this is NodePath<t.DirectiveLiteral>;
	isDoExpression(props?: object | null): this is NodePath<t.DoExpression>;
	isDoWhileStatement(props?: object | null): this is NodePath<t.DoWhileStatement>;
	isEmptyStatement(props?: object | null): this is NodePath<t.EmptyStatement>;
	isEmptyTypeAnnotation(props?: object | null): this is NodePath<t.EmptyTypeAnnotation>;
	isExistsTypeAnnotation(props?: object | null): this is NodePath<t.ExistsTypeAnnotation>;
	isExportAllDeclaration(props?: object | null): this is NodePath<t.ExportAllDeclaration>;
	isExportDeclaration(props?: object | null): this is NodePath<t.ExportDeclaration>;
	isExportDefaultDeclaration(props?: object | null): this is NodePath<t.ExportDefaultDeclaration>;
	isExportDefaultSpecifier(props?: object | null): this is NodePath<t.ExportDefaultSpecifier>;
	isExportNamedDeclaration(props?: object | null): this is NodePath<t.ExportNamedDeclaration>;
	isExportNamespaceSpecifier(props?: object | null): this is NodePath<t.ExportNamespaceSpecifier>;
	isExportSpecifier(props?: object | null): this is NodePath<t.ExportSpecifier>;
	isExpression(props?: object | null): this is NodePath<t.Expression>;
	isExpressionStatement(props?: object | null): this is NodePath<t.ExpressionStatement>;
	isExpressionWrapper(props?: object | null): this is NodePath<t.ExpressionWrapper>;
	isFile(props?: object | null): this is NodePath<t.File>;
	isFlow(props?: object | null): this is NodePath<t.Flow>;
	isFlowBaseAnnotation(props?: object | null): this is NodePath<t.FlowBaseAnnotation>;
	isFlowDeclaration(props?: object | null): this is NodePath<t.FlowDeclaration>;
	isFlowPredicate(props?: object | null): this is NodePath<t.FlowPredicate>;
	isFlowType(props?: object | null): this is NodePath<t.FlowType>;
	isFor(props?: object | null): this is NodePath<t.For>;
	isForInStatement(props?: object | null): this is NodePath<t.ForInStatement>;
	isForOfStatement(props?: object | null): this is NodePath<t.ForOfStatement>;
	isForStatement(props?: object | null): this is NodePath<t.ForStatement>;
	isForXStatement(props?: object | null): this is NodePath<t.ForXStatement>;
	isFunction(props?: object | null): this is NodePath<t.Function>;
	isFunctionDeclaration(props?: object | null): this is NodePath<t.FunctionDeclaration>;
	isFunctionExpression(props?: object | null): this is NodePath<t.FunctionExpression>;
	isFunctionParent(props?: object | null): this is NodePath<t.FunctionParent>;
	isFunctionTypeAnnotation(props?: object | null): this is NodePath<t.FunctionTypeAnnotation>;
	isFunctionTypeParam(props?: object | null): this is NodePath<t.FunctionTypeParam>;
	isGenericTypeAnnotation(props?: object | null): this is NodePath<t.GenericTypeAnnotation>;
	isIdentifier(props?: object | null): this is NodePath<t.Identifier>;
	isIfStatement(props?: object | null): this is NodePath<t.IfStatement>;
	isImmutable(props?: object | null): this is NodePath<t.Immutable>;
	isImport(props?: object | null): this is NodePath<t.Import>;
	isImportDeclaration(props?: object | null): this is NodePath<t.ImportDeclaration>;
	isImportDefaultSpecifier(props?: object | null): this is NodePath<t.ImportDefaultSpecifier>;
	isImportNamespaceSpecifier(props?: object | null): this is NodePath<t.ImportNamespaceSpecifier>;
	isImportSpecifier(props?: object | null): this is NodePath<t.ImportSpecifier>;
	isInferredPredicate(props?: object | null): this is NodePath<t.InferredPredicate>;
	isInterfaceDeclaration(props?: object | null): this is NodePath<t.InterfaceDeclaration>;
	isInterfaceExtends(props?: object | null): this is NodePath<t.InterfaceExtends>;
	isInterfaceTypeAnnotation(props?: object | null): this is NodePath<t.InterfaceTypeAnnotation>;
	isInterpreterDirective(props?: object | null): this is NodePath<t.InterpreterDirective>;
	isIntersectionTypeAnnotation(props?: object | null): this is NodePath<t.IntersectionTypeAnnotation>;
	isJSX(props?: object | null): this is NodePath<t.JSX>;
	isJSXAttribute(props?: object | null): this is NodePath<t.JSXAttribute>;
	isJSXClosingElement(props?: object | null): this is NodePath<t.JSXClosingElement>;
	isJSXClosingFragment(props?: object | null): this is NodePath<t.JSXClosingFragment>;
	isJSXElement(props?: object | null): this is NodePath<t.JSXElement>;
	isJSXEmptyExpression(props?: object | null): this is NodePath<t.JSXEmptyExpression>;
	isJSXExpressionContainer(props?: object | null): this is NodePath<t.JSXExpressionContainer>;
	isJSXFragment(props?: object | null): this is NodePath<t.JSXFragment>;
	isJSXIdentifier(props?: object | null): this is NodePath<t.JSXIdentifier>;
	isJSXMemberExpression(props?: object | null): this is NodePath<t.JSXMemberExpression>;
	isJSXNamespacedName(props?: object | null): this is NodePath<t.JSXNamespacedName>;
	isJSXOpeningElement(props?: object | null): this is NodePath<t.JSXOpeningElement>;
	isJSXOpeningFragment(props?: object | null): this is NodePath<t.JSXOpeningFragment>;
	isJSXSpreadAttribute(props?: object | null): this is NodePath<t.JSXSpreadAttribute>;
	isJSXSpreadChild(props?: object | null): this is NodePath<t.JSXSpreadChild>;
	isJSXText(props?: object | null): this is NodePath<t.JSXText>;
	isLVal(props?: object | null): this is NodePath<t.LVal>;
	isLabeledStatement(props?: object | null): this is NodePath<t.LabeledStatement>;
	isLiteral(props?: object | null): this is NodePath<t.Literal>;
	isLogicalExpression(props?: object | null): this is NodePath<t.LogicalExpression>;
	isLoop(props?: object | null): this is NodePath<t.Loop>;
	isMemberExpression(props?: object | null): this is NodePath<t.MemberExpression>;
	isMetaProperty(props?: object | null): this is NodePath<t.MetaProperty>;
	isMethod(props?: object | null): this is NodePath<t.Method>;
	isMixedTypeAnnotation(props?: object | null): this is NodePath<t.MixedTypeAnnotation>;
	isModuleDeclaration(props?: object | null): this is NodePath<t.ModuleDeclaration>;
	isModuleSpecifier(props?: object | null): this is NodePath<t.ModuleSpecifier>;
	isNewExpression(props?: object | null): this is NodePath<t.NewExpression>;
	isNoop(props?: object | null): this is NodePath<t.Noop>;
	isNullLiteral(props?: object | null): this is NodePath<t.NullLiteral>;
	isNullLiteralTypeAnnotation(props?: object | null): this is NodePath<t.NullLiteralTypeAnnotation>;
	isNullableTypeAnnotation(props?: object | null): this is NodePath<t.NullableTypeAnnotation>;
	/** @deprecated Use `isNumericLiteral` */
	isNumberLiteral(props?: object | null): this is NodePath<t.NumericLiteral>;
	isNumberLiteralTypeAnnotation(props?: object | null): this is NodePath<t.NumberLiteralTypeAnnotation>;
	isNumberTypeAnnotation(props?: object | null): this is NodePath<t.NumberTypeAnnotation>;
	isNumericLiteral(props?: object | null): this is NodePath<t.NumericLiteral>;
	isObjectExpression(props?: object | null): this is NodePath<t.ObjectExpression>;
	isObjectMember(props?: object | null): this is NodePath<t.ObjectMember>;
	isObjectMethod(props?: object | null): this is NodePath<t.ObjectMethod>;
	isObjectPattern(props?: object | null): this is NodePath<t.ObjectPattern>;
	isObjectProperty(props?: object | null): this is NodePath<t.ObjectProperty>;
	isObjectTypeAnnotation(props?: object | null): this is NodePath<t.ObjectTypeAnnotation>;
	isObjectTypeCallProperty(props?: object | null): this is NodePath<t.ObjectTypeCallProperty>;
	isObjectTypeIndexer(props?: object | null): this is NodePath<t.ObjectTypeIndexer>;
	isObjectTypeInternalSlot(props?: object | null): this is NodePath<t.ObjectTypeInternalSlot>;
	isObjectTypeProperty(props?: object | null): this is NodePath<t.ObjectTypeProperty>;
	isObjectTypeSpreadProperty(props?: object | null): this is NodePath<t.ObjectTypeSpreadProperty>;
	isOpaqueType(props?: object | null): this is NodePath<t.OpaqueType>;
	isOptionalCallExpression(props?: object | null): this is NodePath<t.OptionalCallExpression>;
	isOptionalMemberExpression(props?: object | null): this is NodePath<t.OptionalMemberExpression>;
	isParenthesizedExpression(props?: object | null): this is NodePath<t.ParenthesizedExpression>;
	isPattern(props?: object | null): this is NodePath<t.Pattern>;
	isPatternLike(props?: object | null): this is NodePath<t.PatternLike>;
	isPipelineBareFunction(props?: object | null): this is NodePath<t.PipelineBareFunction>;
	isPipelinePrimaryTopicReference(props?: object | null): this is NodePath<t.PipelinePrimaryTopicReference>;
	isPipelineTopicExpression(props?: object | null): this is NodePath<t.PipelineTopicExpression>;
	isPrivate(props?: object | null): this is NodePath<t.Private>;
	isPrivateName(props?: object | null): this is NodePath<t.PrivateName>;
	isProgram(props?: object | null): this is NodePath<t.Program>;
	isProperty(props?: object | null): this is NodePath<t.Property>;
	isPureish(props?: object | null): this is NodePath<t.Pureish>;
	isQualifiedTypeIdentifier(props?: object | null): this is NodePath<t.QualifiedTypeIdentifier>;
	isRegExpLiteral(props?: object | null): this is NodePath<t.RegExpLiteral>;
	/** @deprecated Use `isRegExpLiteral` */
	isRegexLiteral(props?: object | null): this is NodePath<t.RegExpLiteral>;
	isRestElement(props?: object | null): this is NodePath<t.RestElement>;
	/** @deprecated Use `isRestElement` */
	isRestProperty(props?: object | null): this is NodePath<t.RestElement>;
	isReturnStatement(props?: object | null): this is NodePath<t.ReturnStatement>;
	isScopable(props?: object | null): this is NodePath<t.Scopable>;
	isSequenceExpression(props?: object | null): this is NodePath<t.SequenceExpression>;
	isSpreadElement(props?: object | null): this is NodePath<t.SpreadElement>;
	/** @deprecated Use `isSpreadElement` */
	isSpreadProperty(props?: object | null): this is NodePath<t.SpreadElement>;
	isStatement(props?: object | null): this is NodePath<t.Statement>;
	isStringLiteral(props?: object | null): this is NodePath<t.StringLiteral>;
	isStringLiteralTypeAnnotation(props?: object | null): this is NodePath<t.StringLiteralTypeAnnotation>;
	isStringTypeAnnotation(props?: object | null): this is NodePath<t.StringTypeAnnotation>;
	isSuper(props?: object | null): this is NodePath<t.Super>;
	isSwitchCase(props?: object | null): this is NodePath<t.SwitchCase>;
	isSwitchStatement(props?: object | null): this is NodePath<t.SwitchStatement>;
	isTSAnyKeyword(props?: object | null): this is NodePath<t.TSAnyKeyword>;
	isTSArrayType(props?: object | null): this is NodePath<t.TSArrayType>;
	isTSAsExpression(props?: object | null): this is NodePath<t.TSAsExpression>;
	isTSBooleanKeyword(props?: object | null): this is NodePath<t.TSBooleanKeyword>;
	isTSCallSignatureDeclaration(props?: object | null): this is NodePath<t.TSCallSignatureDeclaration>;
	isTSConditionalType(props?: object | null): this is NodePath<t.TSConditionalType>;
	isTSConstructSignatureDeclaration(props?: object | null): this is NodePath<t.TSConstructSignatureDeclaration>;
	isTSConstructorType(props?: object | null): this is NodePath<t.TSConstructorType>;
	isTSDeclareFunction(props?: object | null): this is NodePath<t.TSDeclareFunction>;
	isTSDeclareMethod(props?: object | null): this is NodePath<t.TSDeclareMethod>;
	isTSEntityName(props?: object | null): this is NodePath<t.TSEntityName>;
	isTSEnumDeclaration(props?: object | null): this is NodePath<t.TSEnumDeclaration>;
	isTSEnumMember(props?: object | null): this is NodePath<t.TSEnumMember>;
	isTSExportAssignment(props?: object | null): this is NodePath<t.TSExportAssignment>;
	isTSExpressionWithTypeArguments(props?: object | null): this is NodePath<t.TSExpressionWithTypeArguments>;
	isTSExternalModuleReference(props?: object | null): this is NodePath<t.TSExternalModuleReference>;
	isTSFunctionType(props?: object | null): this is NodePath<t.TSFunctionType>;
	isTSImportEqualsDeclaration(props?: object | null): this is NodePath<t.TSImportEqualsDeclaration>;
	isTSImportType(props?: object | null): this is NodePath<t.TSImportType>;
	isTSIndexSignature(props?: object | null): this is NodePath<t.TSIndexSignature>;
	isTSIndexedAccessType(props?: object | null): this is NodePath<t.TSIndexedAccessType>;
	isTSInferType(props?: object | null): this is NodePath<t.TSInferType>;
	isTSInterfaceBody(props?: object | null): this is NodePath<t.TSInterfaceBody>;
	isTSInterfaceDeclaration(props?: object | null): this is NodePath<t.TSInterfaceDeclaration>;
	isTSIntersectionType(props?: object | null): this is NodePath<t.TSIntersectionType>;
	isTSLiteralType(props?: object | null): this is NodePath<t.TSLiteralType>;
	isTSMappedType(props?: object | null): this is NodePath<t.TSMappedType>;
	isTSMethodSignature(props?: object | null): this is NodePath<t.TSMethodSignature>;
	isTSModuleBlock(props?: object | null): this is NodePath<t.TSModuleBlock>;
	isTSModuleDeclaration(props?: object | null): this is NodePath<t.TSModuleDeclaration>;
	isTSNamespaceExportDeclaration(props?: object | null): this is NodePath<t.TSNamespaceExportDeclaration>;
	isTSNeverKeyword(props?: object | null): this is NodePath<t.TSNeverKeyword>;
	isTSNonNullExpression(props?: object | null): this is NodePath<t.TSNonNullExpression>;
	isTSNullKeyword(props?: object | null): this is NodePath<t.TSNullKeyword>;
	isTSNumberKeyword(props?: object | null): this is NodePath<t.TSNumberKeyword>;
	isTSObjectKeyword(props?: object | null): this is NodePath<t.TSObjectKeyword>;
	isTSOptionalType(props?: object | null): this is NodePath<t.TSOptionalType>;
	isTSParameterProperty(props?: object | null): this is NodePath<t.TSParameterProperty>;
	isTSParenthesizedType(props?: object | null): this is NodePath<t.TSParenthesizedType>;
	isTSPropertySignature(props?: object | null): this is NodePath<t.TSPropertySignature>;
	isTSQualifiedName(props?: object | null): this is NodePath<t.TSQualifiedName>;
	isTSRestType(props?: object | null): this is NodePath<t.TSRestType>;
	isTSStringKeyword(props?: object | null): this is NodePath<t.TSStringKeyword>;
	isTSSymbolKeyword(props?: object | null): this is NodePath<t.TSSymbolKeyword>;
	isTSThisType(props?: object | null): this is NodePath<t.TSThisType>;
	isTSTupleType(props?: object | null): this is NodePath<t.TSTupleType>;
	isTSType(props?: object | null): this is NodePath<t.TSType>;
	isTSTypeAliasDeclaration(props?: object | null): this is NodePath<t.TSTypeAliasDeclaration>;
	isTSTypeAnnotation(props?: object | null): this is NodePath<t.TSTypeAnnotation>;
	isTSTypeAssertion(props?: object | null): this is NodePath<t.TSTypeAssertion>;
	isTSTypeElement(props?: object | null): this is NodePath<t.TSTypeElement>;
	isTSTypeLiteral(props?: object | null): this is NodePath<t.TSTypeLiteral>;
	isTSTypeOperator(props?: object | null): this is NodePath<t.TSTypeOperator>;
	isTSTypeParameter(props?: object | null): this is NodePath<t.TSTypeParameter>;
	isTSTypeParameterDeclaration(props?: object | null): this is NodePath<t.TSTypeParameterDeclaration>;
	isTSTypeParameterInstantiation(props?: object | null): this is NodePath<t.TSTypeParameterInstantiation>;
	isTSTypePredicate(props?: object | null): this is NodePath<t.TSTypePredicate>;
	isTSTypeQuery(props?: object | null): this is NodePath<t.TSTypeQuery>;
	isTSTypeReference(props?: object | null): this is NodePath<t.TSTypeReference>;
	isTSUndefinedKeyword(props?: object | null): this is NodePath<t.TSUndefinedKeyword>;
	isTSUnionType(props?: object | null): this is NodePath<t.TSUnionType>;
	isTSUnknownKeyword(props?: object | null): this is NodePath<t.TSUnknownKeyword>;
	isTSVoidKeyword(props?: object | null): this is NodePath<t.TSVoidKeyword>;
	isTaggedTemplateExpression(props?: object | null): this is NodePath<t.TaggedTemplateExpression>;
	isTemplateElement(props?: object | null): this is NodePath<t.TemplateElement>;
	isTemplateLiteral(props?: object | null): this is NodePath<t.TemplateLiteral>;
	isTerminatorless(props?: object | null): this is NodePath<t.Terminatorless>;
	isThisExpression(props?: object | null): this is NodePath<t.ThisExpression>;
	isThisTypeAnnotation(props?: object | null): this is NodePath<t.ThisTypeAnnotation>;
	isThrowStatement(props?: object | null): this is NodePath<t.ThrowStatement>;
	isTryStatement(props?: object | null): this is NodePath<t.TryStatement>;
	isTupleTypeAnnotation(props?: object | null): this is NodePath<t.TupleTypeAnnotation>;
	isTypeAlias(props?: object | null): this is NodePath<t.TypeAlias>;
	isTypeAnnotation(props?: object | null): this is NodePath<t.TypeAnnotation>;
	isTypeCastExpression(props?: object | null): this is NodePath<t.TypeCastExpression>;
	isTypeParameter(props?: object | null): this is NodePath<t.TypeParameter>;
	isTypeParameterDeclaration(props?: object | null): this is NodePath<t.TypeParameterDeclaration>;
	isTypeParameterInstantiation(props?: object | null): this is NodePath<t.TypeParameterInstantiation>;
	isTypeofTypeAnnotation(props?: object | null): this is NodePath<t.TypeofTypeAnnotation>;
	isUnaryExpression(props?: object | null): this is NodePath<t.UnaryExpression>;
	isUnaryLike(props?: object | null): this is NodePath<t.UnaryLike>;
	isUnionTypeAnnotation(props?: object | null): this is NodePath<t.UnionTypeAnnotation>;
	isUpdateExpression(props?: object | null): this is NodePath<t.UpdateExpression>;
	isUserWhitespacable(props?: object | null): this is NodePath<t.UserWhitespacable>;
	isVariableDeclaration(props?: object | null): this is NodePath<t.VariableDeclaration>;
	isVariableDeclarator(props?: object | null): this is NodePath<t.VariableDeclarator>;
	isVariance(props?: object | null): this is NodePath<t.Variance>;
	isVoidTypeAnnotation(props?: object | null): this is NodePath<t.VoidTypeAnnotation>;
	isWhile(props?: object | null): this is NodePath<t.While>;
	isWhileStatement(props?: object | null): this is NodePath<t.WhileStatement>;
	isWithStatement(props?: object | null): this is NodePath<t.WithStatement>;
	isYieldExpression(props?: object | null): this is NodePath<t.YieldExpression>;
	isBindingIdentifier(props?: object | null): this is NodePath<t.Identifier>;
	isBlockScoped(props?: object | null): this is NodePath<t.FunctionDeclaration | t.ClassDeclaration | t.VariableDeclaration>;
	isGenerated(props?: object | null): boolean;
	isPure(props?: object | null): boolean;
	isReferenced(props?: object | null): boolean;
	isReferencedIdentifier(props?: object | null): this is NodePath<t.Identifier | t.JSXIdentifier>;
	isReferencedMemberExpression(props?: object | null): this is NodePath<t.MemberExpression>;
	isScope(props?: object | null): this is NodePath<t.Scopable>;
	isUser(props?: object | null): boolean;
	isVar(props?: object | null): this is NodePath<t.VariableDeclaration>;
	//#endregion
	//#region ------------------------- assertXXX -------------------------
	assertAnyTypeAnnotation(props?: object | null): void;
	assertArrayExpression(props?: object | null): void;
	assertArrayPattern(props?: object | null): void;
	assertArrayTypeAnnotation(props?: object | null): void;
	assertArrowFunctionExpression(props?: object | null): void;
	assertAssignmentExpression(props?: object | null): void;
	assertAssignmentPattern(props?: object | null): void;
	assertAwaitExpression(props?: object | null): void;
	assertBigIntLiteral(props?: object | null): void;
	assertBinary(props?: object | null): void;
	assertBinaryExpression(props?: object | null): void;
	assertBindExpression(props?: object | null): void;
	assertBlock(props?: object | null): void;
	assertBlockParent(props?: object | null): void;
	assertBlockStatement(props?: object | null): void;
	assertBooleanLiteral(props?: object | null): void;
	assertBooleanLiteralTypeAnnotation(props?: object | null): void;
	assertBooleanTypeAnnotation(props?: object | null): void;
	assertBreakStatement(props?: object | null): void;
	assertCallExpression(props?: object | null): void;
	assertCatchClause(props?: object | null): void;
	assertClass(props?: object | null): void;
	assertClassBody(props?: object | null): void;
	assertClassDeclaration(props?: object | null): void;
	assertClassExpression(props?: object | null): void;
	assertClassImplements(props?: object | null): void;
	assertClassMethod(props?: object | null): void;
	assertClassPrivateMethod(props?: object | null): void;
	assertClassPrivateProperty(props?: object | null): void;
	assertClassProperty(props?: object | null): void;
	assertCompletionStatement(props?: object | null): void;
	assertConditional(props?: object | null): void;
	assertConditionalExpression(props?: object | null): void;
	assertContinueStatement(props?: object | null): void;
	assertDebuggerStatement(props?: object | null): void;
	assertDeclaration(props?: object | null): void;
	assertDeclareClass(props?: object | null): void;
	assertDeclareExportAllDeclaration(props?: object | null): void;
	assertDeclareExportDeclaration(props?: object | null): void;
	assertDeclareFunction(props?: object | null): void;
	assertDeclareInterface(props?: object | null): void;
	assertDeclareModule(props?: object | null): void;
	assertDeclareModuleExports(props?: object | null): void;
	assertDeclareOpaqueType(props?: object | null): void;
	assertDeclareTypeAlias(props?: object | null): void;
	assertDeclareVariable(props?: object | null): void;
	assertDeclaredPredicate(props?: object | null): void;
	assertDecorator(props?: object | null): void;
	assertDirective(props?: object | null): void;
	assertDirectiveLiteral(props?: object | null): void;
	assertDoExpression(props?: object | null): void;
	assertDoWhileStatement(props?: object | null): void;
	assertEmptyStatement(props?: object | null): void;
	assertEmptyTypeAnnotation(props?: object | null): void;
	assertExistsTypeAnnotation(props?: object | null): void;
	assertExportAllDeclaration(props?: object | null): void;
	assertExportDeclaration(props?: object | null): void;
	assertExportDefaultDeclaration(props?: object | null): void;
	assertExportDefaultSpecifier(props?: object | null): void;
	assertExportNamedDeclaration(props?: object | null): void;
	assertExportNamespaceSpecifier(props?: object | null): void;
	assertExportSpecifier(props?: object | null): void;
	assertExpression(props?: object | null): void;
	assertExpressionStatement(props?: object | null): void;
	assertExpressionWrapper(props?: object | null): void;
	assertFile(props?: object | null): void;
	assertFlow(props?: object | null): void;
	assertFlowBaseAnnotation(props?: object | null): void;
	assertFlowDeclaration(props?: object | null): void;
	assertFlowPredicate(props?: object | null): void;
	assertFlowType(props?: object | null): void;
	assertFor(props?: object | null): void;
	assertForInStatement(props?: object | null): void;
	assertForOfStatement(props?: object | null): void;
	assertForStatement(props?: object | null): void;
	assertForXStatement(props?: object | null): void;
	assertFunction(props?: object | null): void;
	assertFunctionDeclaration(props?: object | null): void;
	assertFunctionExpression(props?: object | null): void;
	assertFunctionParent(props?: object | null): void;
	assertFunctionTypeAnnotation(props?: object | null): void;
	assertFunctionTypeParam(props?: object | null): void;
	assertGenericTypeAnnotation(props?: object | null): void;
	assertIdentifier(props?: object | null): void;
	assertIfStatement(props?: object | null): void;
	assertImmutable(props?: object | null): void;
	assertImport(props?: object | null): void;
	assertImportDeclaration(props?: object | null): void;
	assertImportDefaultSpecifier(props?: object | null): void;
	assertImportNamespaceSpecifier(props?: object | null): void;
	assertImportSpecifier(props?: object | null): void;
	assertInferredPredicate(props?: object | null): void;
	assertInterfaceDeclaration(props?: object | null): void;
	assertInterfaceExtends(props?: object | null): void;
	assertInterfaceTypeAnnotation(props?: object | null): void;
	assertInterpreterDirective(props?: object | null): void;
	assertIntersectionTypeAnnotation(props?: object | null): void;
	assertJSX(props?: object | null): void;
	assertJSXAttribute(props?: object | null): void;
	assertJSXClosingElement(props?: object | null): void;
	assertJSXClosingFragment(props?: object | null): void;
	assertJSXElement(props?: object | null): void;
	assertJSXEmptyExpression(props?: object | null): void;
	assertJSXExpressionContainer(props?: object | null): void;
	assertJSXFragment(props?: object | null): void;
	assertJSXIdentifier(props?: object | null): void;
	assertJSXMemberExpression(props?: object | null): void;
	assertJSXNamespacedName(props?: object | null): void;
	assertJSXOpeningElement(props?: object | null): void;
	assertJSXOpeningFragment(props?: object | null): void;
	assertJSXSpreadAttribute(props?: object | null): void;
	assertJSXSpreadChild(props?: object | null): void;
	assertJSXText(props?: object | null): void;
	assertLVal(props?: object | null): void;
	assertLabeledStatement(props?: object | null): void;
	assertLiteral(props?: object | null): void;
	assertLogicalExpression(props?: object | null): void;
	assertLoop(props?: object | null): void;
	assertMemberExpression(props?: object | null): void;
	assertMetaProperty(props?: object | null): void;
	assertMethod(props?: object | null): void;
	assertMixedTypeAnnotation(props?: object | null): void;
	assertModuleDeclaration(props?: object | null): void;
	assertModuleSpecifier(props?: object | null): void;
	assertNewExpression(props?: object | null): void;
	assertNoop(props?: object | null): void;
	assertNullLiteral(props?: object | null): void;
	assertNullLiteralTypeAnnotation(props?: object | null): void;
	assertNullableTypeAnnotation(props?: object | null): void;
	/** @deprecated Use `assertNumericLiteral` */
	assertNumberLiteral(props?: object | null): void;
	assertNumberLiteralTypeAnnotation(props?: object | null): void;
	assertNumberTypeAnnotation(props?: object | null): void;
	assertNumericLiteral(props?: object | null): void;
	assertObjectExpression(props?: object | null): void;
	assertObjectMember(props?: object | null): void;
	assertObjectMethod(props?: object | null): void;
	assertObjectPattern(props?: object | null): void;
	assertObjectProperty(props?: object | null): void;
	assertObjectTypeAnnotation(props?: object | null): void;
	assertObjectTypeCallProperty(props?: object | null): void;
	assertObjectTypeIndexer(props?: object | null): void;
	assertObjectTypeInternalSlot(props?: object | null): void;
	assertObjectTypeProperty(props?: object | null): void;
	assertObjectTypeSpreadProperty(props?: object | null): void;
	assertOpaqueType(props?: object | null): void;
	assertOptionalCallExpression(props?: object | null): void;
	assertOptionalMemberExpression(props?: object | null): void;
	assertParenthesizedExpression(props?: object | null): void;
	assertPattern(props?: object | null): void;
	assertPatternLike(props?: object | null): void;
	assertPipelineBareFunction(props?: object | null): void;
	assertPipelinePrimaryTopicReference(props?: object | null): void;
	assertPipelineTopicExpression(props?: object | null): void;
	assertPrivate(props?: object | null): void;
	assertPrivateName(props?: object | null): void;
	assertProgram(props?: object | null): void;
	assertProperty(props?: object | null): void;
	assertPureish(props?: object | null): void;
	assertQualifiedTypeIdentifier(props?: object | null): void;
	assertRegExpLiteral(props?: object | null): void;
	/** @deprecated Use `assertRegExpLiteral` */
	assertRegexLiteral(props?: object | null): void;
	assertRestElement(props?: object | null): void;
	/** @deprecated Use `assertRestElement` */
	assertRestProperty(props?: object | null): void;
	assertReturnStatement(props?: object | null): void;
	assertScopable(props?: object | null): void;
	assertSequenceExpression(props?: object | null): void;
	assertSpreadElement(props?: object | null): void;
	/** @deprecated Use `assertSpreadElement` */
	assertSpreadProperty(props?: object | null): void;
	assertStatement(props?: object | null): void;
	assertStringLiteral(props?: object | null): void;
	assertStringLiteralTypeAnnotation(props?: object | null): void;
	assertStringTypeAnnotation(props?: object | null): void;
	assertSuper(props?: object | null): void;
	assertSwitchCase(props?: object | null): void;
	assertSwitchStatement(props?: object | null): void;
	assertTSAnyKeyword(props?: object | null): void;
	assertTSArrayType(props?: object | null): void;
	assertTSAsExpression(props?: object | null): void;
	assertTSBooleanKeyword(props?: object | null): void;
	assertTSCallSignatureDeclaration(props?: object | null): void;
	assertTSConditionalType(props?: object | null): void;
	assertTSConstructSignatureDeclaration(props?: object | null): void;
	assertTSConstructorType(props?: object | null): void;
	assertTSDeclareFunction(props?: object | null): void;
	assertTSDeclareMethod(props?: object | null): void;
	assertTSEntityName(props?: object | null): void;
	assertTSEnumDeclaration(props?: object | null): void;
	assertTSEnumMember(props?: object | null): void;
	assertTSExportAssignment(props?: object | null): void;
	assertTSExpressionWithTypeArguments(props?: object | null): void;
	assertTSExternalModuleReference(props?: object | null): void;
	assertTSFunctionType(props?: object | null): void;
	assertTSImportEqualsDeclaration(props?: object | null): void;
	assertTSImportType(props?: object | null): void;
	assertTSIndexSignature(props?: object | null): void;
	assertTSIndexedAccessType(props?: object | null): void;
	assertTSInferType(props?: object | null): void;
	assertTSInterfaceBody(props?: object | null): void;
	assertTSInterfaceDeclaration(props?: object | null): void;
	assertTSIntersectionType(props?: object | null): void;
	assertTSLiteralType(props?: object | null): void;
	assertTSMappedType(props?: object | null): void;
	assertTSMethodSignature(props?: object | null): void;
	assertTSModuleBlock(props?: object | null): void;
	assertTSModuleDeclaration(props?: object | null): void;
	assertTSNamespaceExportDeclaration(props?: object | null): void;
	assertTSNeverKeyword(props?: object | null): void;
	assertTSNonNullExpression(props?: object | null): void;
	assertTSNullKeyword(props?: object | null): void;
	assertTSNumberKeyword(props?: object | null): void;
	assertTSObjectKeyword(props?: object | null): void;
	assertTSOptionalType(props?: object | null): void;
	assertTSParameterProperty(props?: object | null): void;
	assertTSParenthesizedType(props?: object | null): void;
	assertTSPropertySignature(props?: object | null): void;
	assertTSQualifiedName(props?: object | null): void;
	assertTSRestType(props?: object | null): void;
	assertTSStringKeyword(props?: object | null): void;
	assertTSSymbolKeyword(props?: object | null): void;
	assertTSThisType(props?: object | null): void;
	assertTSTupleType(props?: object | null): void;
	assertTSType(props?: object | null): void;
	assertTSTypeAliasDeclaration(props?: object | null): void;
	assertTSTypeAnnotation(props?: object | null): void;
	assertTSTypeAssertion(props?: object | null): void;
	assertTSTypeElement(props?: object | null): void;
	assertTSTypeLiteral(props?: object | null): void;
	assertTSTypeOperator(props?: object | null): void;
	assertTSTypeParameter(props?: object | null): void;
	assertTSTypeParameterDeclaration(props?: object | null): void;
	assertTSTypeParameterInstantiation(props?: object | null): void;
	assertTSTypePredicate(props?: object | null): void;
	assertTSTypeQuery(props?: object | null): void;
	assertTSTypeReference(props?: object | null): void;
	assertTSUndefinedKeyword(props?: object | null): void;
	assertTSUnionType(props?: object | null): void;
	assertTSUnknownKeyword(props?: object | null): void;
	assertTSVoidKeyword(props?: object | null): void;
	assertTaggedTemplateExpression(props?: object | null): void;
	assertTemplateElement(props?: object | null): void;
	assertTemplateLiteral(props?: object | null): void;
	assertTerminatorless(props?: object | null): void;
	assertThisExpression(props?: object | null): void;
	assertThisTypeAnnotation(props?: object | null): void;
	assertThrowStatement(props?: object | null): void;
	assertTryStatement(props?: object | null): void;
	assertTupleTypeAnnotation(props?: object | null): void;
	assertTypeAlias(props?: object | null): void;
	assertTypeAnnotation(props?: object | null): void;
	assertTypeCastExpression(props?: object | null): void;
	assertTypeParameter(props?: object | null): void;
	assertTypeParameterDeclaration(props?: object | null): void;
	assertTypeParameterInstantiation(props?: object | null): void;
	assertTypeofTypeAnnotation(props?: object | null): void;
	assertUnaryExpression(props?: object | null): void;
	assertUnaryLike(props?: object | null): void;
	assertUnionTypeAnnotation(props?: object | null): void;
	assertUpdateExpression(props?: object | null): void;
	assertUserWhitespacable(props?: object | null): void;
	assertVariableDeclaration(props?: object | null): void;
	assertVariableDeclarator(props?: object | null): void;
	assertVariance(props?: object | null): void;
	assertVoidTypeAnnotation(props?: object | null): void;
	assertWhile(props?: object | null): void;
	assertWhileStatement(props?: object | null): void;
	assertWithStatement(props?: object | null): void;
	assertYieldExpression(props?: object | null): void;
	assertBindingIdentifier(props?: object | null): void;
	assertBlockScoped(props?: object | null): void;
	assertGenerated(props?: object | null): void;
	assertPure(props?: object | null): void;
	assertReferenced(props?: object | null): void;
	assertReferencedIdentifier(props?: object | null): void;
	assertReferencedMemberExpression(props?: object | null): void;
	assertScope(props?: object | null): void;
	assertUser(props?: object | null): void;
	assertVar(props?: object | null): void;
}
export interface HubInterface {
	getCode(): string | undefined;
	getScope(): Scope | undefined;
	addHelper(name: string): any;
	buildError<E extends Error>(node: Node, msg: string, Error: new (message?: string) => E): E;
}
declare class Hub implements HubInterface {
	constructor();
	getCode(): string | undefined;
	getScope(): Scope | undefined;
	addHelper(name: string): any;
	buildError<E extends Error>(node: Node, msg: string, Constructor: new (message?: string) => E): E;
}
export interface TraversalContext {
	parentPath: NodePath;
	scope: Scope;
	state: any;
	opts: any;
}
export default traverse;

export {};
